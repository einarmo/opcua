// This file was autogenerated from schemas/1.0.4/Opc.Ua.Types.bsd by opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Adam Lock, Einar Omang
#[allow(unused)]
mod opcua {
    pub use crate as types;
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelExType : i32 { const
    None = 0i32; const CurrentRead = 1i32; const CurrentWrite = 2i32; const HistoryRead =
    4i32; const HistoryWrite = 8i32; const SemanticChange = 16i32; const StatusWrite =
    32i32; const TimestampWrite = 64i32; const NonatomicRead = 256i32; const
    NonatomicWrite = 512i32; const WriteFullArrayOnly = 1024i32; const NoSubDataTypes =
    2048i32; }
}
impl opcua::types::BinaryEncodable for AccessLevelExType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessLevelExType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for AccessLevelExType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelExType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessLevelExType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessLevelExType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessLevelExType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelType : u8 { const None
    = 0u8; const CurrentRead = 1u8; const CurrentWrite = 2u8; const HistoryRead = 4u8;
    const HistoryWrite = 8u8; const SemanticChange = 16u8; const StatusWrite = 32u8;
    const TimestampWrite = 64u8; }
}
impl opcua::types::BinaryEncodable for AccessLevelType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        1usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessLevelType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
impl Default for AccessLevelType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessLevelType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessLevelType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessLevelType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessLevelType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessRestrictionType : i16 {
    const None = 0i16; const SigningRequired = 1i16; const EncryptionRequired = 2i16;
    const SessionRequired = 4i16; const ApplyRestrictionsToBrowse = 8i16; }
}
impl opcua::types::BinaryEncodable for AccessRestrictionType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        2usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AccessRestrictionType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
impl Default for AccessRestrictionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AccessRestrictionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessRestrictionType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i16::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AccessRestrictionType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AccessRestrictionType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ApplicationType {
    Server = 0i32,
    Client = 1i32,
    ClientAndServer = 2i32,
    DiscoveryServer = 3i32,
}
impl Default for ApplicationType {
    fn default() -> Self {
        Self::Server
    }
}
impl TryFrom<i32> for ApplicationType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Server,
            1i32 => Self::Client,
            2i32 => Self::ClientAndServer,
            3i32 => Self::DiscoveryServer,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum ApplicationType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ApplicationType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum ApplicationType: {}", e))?)
    }
}
impl From<ApplicationType> for i32 {
    fn from(value: ApplicationType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for ApplicationType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for ApplicationType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for ApplicationType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for ApplicationType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for ApplicationType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AttributeWriteMask : i32 { const
    None = 0i32; const AccessLevel = 1i32; const ArrayDimensions = 2i32; const BrowseName
    = 4i32; const ContainsNoLoops = 8i32; const DataType = 16i32; const Description =
    32i32; const DisplayName = 64i32; const EventNotifier = 128i32; const Executable =
    256i32; const Historizing = 512i32; const InverseName = 1024i32; const IsAbstract =
    2048i32; const MinimumSamplingInterval = 4096i32; const NodeClass = 8192i32; const
    NodeId = 16384i32; const Symmetric = 32768i32; const UserAccessLevel = 65536i32;
    const UserExecutable = 131072i32; const UserWriteMask = 262144i32; const ValueRank =
    524288i32; const WriteMask = 1048576i32; const ValueForVariableType = 2097152i32;
    const DataTypeDefinition = 4194304i32; const RolePermissions = 8388608i32; const
    AccessRestrictions = 16777216i32; const AccessLevelEx = 33554432i32; }
}
impl opcua::types::BinaryEncodable for AttributeWriteMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for AttributeWriteMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for AttributeWriteMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for AttributeWriteMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AttributeWriteMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AttributeWriteMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AttributeWriteMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum AxisScaleEnumeration {
    Linear = 0i32,
    Log = 1i32,
    Ln = 2i32,
}
impl Default for AxisScaleEnumeration {
    fn default() -> Self {
        Self::Linear
    }
}
impl TryFrom<i32> for AxisScaleEnumeration {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Linear,
            1i32 => Self::Log,
            2i32 => Self::Ln,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum AxisScaleEnumeration: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AxisScaleEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum AxisScaleEnumeration: {}", e))?)
    }
}
impl From<AxisScaleEnumeration> for i32 {
    fn from(value: AxisScaleEnumeration) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for AxisScaleEnumeration {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for AxisScaleEnumeration {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for AxisScaleEnumeration {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for AxisScaleEnumeration {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for AxisScaleEnumeration {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrokerTransportQualityOfService {
    NotSpecified = 0i32,
    BestEffort = 1i32,
    AtLeastOnce = 2i32,
    AtMostOnce = 3i32,
    ExactlyOnce = 4i32,
}
impl Default for BrokerTransportQualityOfService {
    fn default() -> Self {
        Self::NotSpecified
    }
}
impl TryFrom<i32> for BrokerTransportQualityOfService {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::NotSpecified,
            1i32 => Self::BestEffort,
            2i32 => Self::AtLeastOnce,
            3i32 => Self::AtMostOnce,
            4i32 => Self::ExactlyOnce,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum BrokerTransportQualityOfService: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrokerTransportQualityOfService {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum BrokerTransportQualityOfService: {}",
                e
            )
        })?)
    }
}
impl From<BrokerTransportQualityOfService> for i32 {
    fn from(value: BrokerTransportQualityOfService) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for BrokerTransportQualityOfService {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for BrokerTransportQualityOfService {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for BrokerTransportQualityOfService {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for BrokerTransportQualityOfService {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for BrokerTransportQualityOfService {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseDirection {
    Forward = 0i32,
    Inverse = 1i32,
    Both = 2i32,
    Invalid = 3i32,
}
impl Default for BrowseDirection {
    fn default() -> Self {
        Self::Forward
    }
}
impl TryFrom<i32> for BrowseDirection {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Forward,
            1i32 => Self::Inverse,
            2i32 => Self::Both,
            3i32 => Self::Invalid,
            r => {
                log::warn!(
                    "Got unexpected value for enum BrowseDirection: {}. Falling back on Invalid",
                    r
                );
                Self::Invalid
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrowseDirection {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum BrowseDirection: {}", e))?)
    }
}
impl From<BrowseDirection> for i32 {
    fn from(value: BrowseDirection) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for BrowseDirection {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for BrowseDirection {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for BrowseDirection {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for BrowseDirection {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for BrowseDirection {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseResultMask {
    None = 0i32,
    ReferenceTypeId = 1i32,
    IsForward = 2i32,
    NodeClass = 4i32,
    BrowseName = 8i32,
    DisplayName = 16i32,
    TypeDefinition = 32i32,
    All = 63i32,
    ReferenceTypeInfo = 3i32,
    TargetInfo = 60i32,
}
impl Default for BrowseResultMask {
    fn default() -> Self {
        Self::None
    }
}
impl TryFrom<i32> for BrowseResultMask {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::None,
            1i32 => Self::ReferenceTypeId,
            2i32 => Self::IsForward,
            4i32 => Self::NodeClass,
            8i32 => Self::BrowseName,
            16i32 => Self::DisplayName,
            32i32 => Self::TypeDefinition,
            63i32 => Self::All,
            3i32 => Self::ReferenceTypeInfo,
            60i32 => Self::TargetInfo,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum BrowseResultMask: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrowseResultMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum BrowseResultMask: {}", e))?)
    }
}
impl From<BrowseResultMask> for i32 {
    fn from(value: BrowseResultMask) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for BrowseResultMask {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for BrowseResultMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for BrowseResultMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for BrowseResultMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for BrowseResultMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataChangeTrigger {
    Status = 0i32,
    StatusValue = 1i32,
    StatusValueTimestamp = 2i32,
}
impl Default for DataChangeTrigger {
    fn default() -> Self {
        Self::Status
    }
}
impl TryFrom<i32> for DataChangeTrigger {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Status,
            1i32 => Self::StatusValue,
            2i32 => Self::StatusValueTimestamp,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum DataChangeTrigger: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataChangeTrigger {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum DataChangeTrigger: {}", e))?)
    }
}
impl From<DataChangeTrigger> for i32 {
    fn from(value: DataChangeTrigger) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for DataChangeTrigger {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataChangeTrigger {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataChangeTrigger {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for DataChangeTrigger {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for DataChangeTrigger {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldContentMask : i32 {
    const None = 0i32; const StatusCode = 1i32; const SourceTimestamp = 2i32; const
    ServerTimestamp = 4i32; const SourcePicoSeconds = 8i32; const ServerPicoSeconds =
    16i32; const RawData = 32i32; }
}
impl opcua::types::BinaryEncodable for DataSetFieldContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for DataSetFieldContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for DataSetFieldContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetFieldContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataSetFieldContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataSetFieldContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldFlags : i16 { const
    None = 0i16; const PromotedField = 1i16; }
}
impl opcua::types::BinaryEncodable for DataSetFieldFlags {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        2usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for DataSetFieldFlags {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, ctx)?))
    }
}
impl Default for DataSetFieldFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for DataSetFieldFlags {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetFieldFlags {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i16::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataSetFieldFlags {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataSetFieldFlags {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataSetOrderingType {
    Undefined = 0i32,
    AscendingWriterId = 1i32,
    AscendingWriterIdSingle = 2i32,
}
impl Default for DataSetOrderingType {
    fn default() -> Self {
        Self::Undefined
    }
}
impl TryFrom<i32> for DataSetOrderingType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Undefined,
            1i32 => Self::AscendingWriterId,
            2i32 => Self::AscendingWriterIdSingle,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum DataSetOrderingType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetOrderingType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum DataSetOrderingType: {}", e))?)
    }
}
impl From<DataSetOrderingType> for i32 {
    fn from(value: DataSetOrderingType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for DataSetOrderingType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DataSetOrderingType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DataSetOrderingType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for DataSetOrderingType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for DataSetOrderingType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DeadbandType {
    None = 0i32,
    Absolute = 1i32,
    Percent = 2i32,
}
impl Default for DeadbandType {
    fn default() -> Self {
        Self::None
    }
}
impl TryFrom<i32> for DeadbandType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::None,
            1i32 => Self::Absolute,
            2i32 => Self::Percent,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum DeadbandType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DeadbandType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum DeadbandType: {}", e))?)
    }
}
impl From<DeadbandType> for i32 {
    fn from(value: DeadbandType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for DeadbandType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DeadbandType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DeadbandType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for DeadbandType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for DeadbandType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DiagnosticsLevel {
    Basic = 0i32,
    Advanced = 1i32,
    Info = 2i32,
    Log = 3i32,
    Debug = 4i32,
}
impl Default for DiagnosticsLevel {
    fn default() -> Self {
        Self::Basic
    }
}
impl TryFrom<i32> for DiagnosticsLevel {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Basic,
            1i32 => Self::Advanced,
            2i32 => Self::Info,
            3i32 => Self::Log,
            4i32 => Self::Debug,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum DiagnosticsLevel: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DiagnosticsLevel {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum DiagnosticsLevel: {}", e))?)
    }
}
impl From<DiagnosticsLevel> for i32 {
    fn from(value: DiagnosticsLevel) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for DiagnosticsLevel {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for DiagnosticsLevel {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for DiagnosticsLevel {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for DiagnosticsLevel {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for DiagnosticsLevel {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct EventNotifierType : u8 { const
    None = 0u8; const SubscribeToEvents = 1u8; const HistoryRead = 4u8; const
    HistoryWrite = 8u8; }
}
impl opcua::types::BinaryEncodable for EventNotifierType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        1usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for EventNotifierType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, ctx)?))
    }
}
impl Default for EventNotifierType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for EventNotifierType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for EventNotifierType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for EventNotifierType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for EventNotifierType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ExceptionDeviationFormat {
    AbsoluteValue = 0i32,
    PercentOfValue = 1i32,
    PercentOfRange = 2i32,
    PercentOfEURange = 3i32,
    Unknown = 4i32,
}
impl Default for ExceptionDeviationFormat {
    fn default() -> Self {
        Self::AbsoluteValue
    }
}
impl TryFrom<i32> for ExceptionDeviationFormat {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::AbsoluteValue,
            1i32 => Self::PercentOfValue,
            2i32 => Self::PercentOfRange,
            3i32 => Self::PercentOfEURange,
            4i32 => Self::Unknown,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum ExceptionDeviationFormat: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ExceptionDeviationFormat {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum ExceptionDeviationFormat: {}",
                e
            )
        })?)
    }
}
impl From<ExceptionDeviationFormat> for i32 {
    fn from(value: ExceptionDeviationFormat) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for ExceptionDeviationFormat {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for ExceptionDeviationFormat {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for ExceptionDeviationFormat {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for ExceptionDeviationFormat {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for ExceptionDeviationFormat {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum FilterOperator {
    Equals = 0i32,
    IsNull = 1i32,
    GreaterThan = 2i32,
    LessThan = 3i32,
    GreaterThanOrEqual = 4i32,
    LessThanOrEqual = 5i32,
    Like = 6i32,
    Not = 7i32,
    Between = 8i32,
    InList = 9i32,
    And = 10i32,
    Or = 11i32,
    Cast = 12i32,
    InView = 13i32,
    OfType = 14i32,
    RelatedTo = 15i32,
    BitwiseAnd = 16i32,
    BitwiseOr = 17i32,
}
impl Default for FilterOperator {
    fn default() -> Self {
        Self::Equals
    }
}
impl TryFrom<i32> for FilterOperator {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Equals,
            1i32 => Self::IsNull,
            2i32 => Self::GreaterThan,
            3i32 => Self::LessThan,
            4i32 => Self::GreaterThanOrEqual,
            5i32 => Self::LessThanOrEqual,
            6i32 => Self::Like,
            7i32 => Self::Not,
            8i32 => Self::Between,
            9i32 => Self::InList,
            10i32 => Self::And,
            11i32 => Self::Or,
            12i32 => Self::Cast,
            13i32 => Self::InView,
            14i32 => Self::OfType,
            15i32 => Self::RelatedTo,
            16i32 => Self::BitwiseAnd,
            17i32 => Self::BitwiseOr,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum FilterOperator: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for FilterOperator {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum FilterOperator: {}", e))?)
    }
}
impl From<FilterOperator> for i32 {
    fn from(value: FilterOperator) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for FilterOperator {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for FilterOperator {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for FilterOperator {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for FilterOperator {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for FilterOperator {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum HistoryUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Delete = 4i32,
}
impl TryFrom<i32> for HistoryUpdateType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::Insert,
            2i32 => Self::Replace,
            3i32 => Self::Update,
            4i32 => Self::Delete,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum HistoryUpdateType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for HistoryUpdateType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum HistoryUpdateType: {}", e))?)
    }
}
impl From<HistoryUpdateType> for i32 {
    fn from(value: HistoryUpdateType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for HistoryUpdateType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for HistoryUpdateType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for HistoryUpdateType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for HistoryUpdateType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for HistoryUpdateType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdentityCriteriaType {
    UserName = 1i32,
    Thumbprint = 2i32,
    Role = 3i32,
    GroupId = 4i32,
    Anonymous = 5i32,
    AuthenticatedUser = 6i32,
}
impl TryFrom<i32> for IdentityCriteriaType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::UserName,
            2i32 => Self::Thumbprint,
            3i32 => Self::Role,
            4i32 => Self::GroupId,
            5i32 => Self::Anonymous,
            6i32 => Self::AuthenticatedUser,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum IdentityCriteriaType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for IdentityCriteriaType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum IdentityCriteriaType: {}", e))?)
    }
}
impl From<IdentityCriteriaType> for i32 {
    fn from(value: IdentityCriteriaType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for IdentityCriteriaType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for IdentityCriteriaType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for IdentityCriteriaType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for IdentityCriteriaType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for IdentityCriteriaType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdType {
    Numeric = 0i32,
    String = 1i32,
    Guid = 2i32,
    Opaque = 3i32,
}
impl Default for IdType {
    fn default() -> Self {
        Self::Numeric
    }
}
impl TryFrom<i32> for IdType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Numeric,
            1i32 => Self::String,
            2i32 => Self::Guid,
            3i32 => Self::Opaque,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum IdType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for IdType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum IdType: {}", e))?)
    }
}
impl From<IdType> for i32 {
    fn from(value: IdType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for IdType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for IdType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for IdType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for IdType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for IdType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonDataSetMessageContentMask :
    i32 { const None = 0i32; const DataSetWriterId = 1i32; const MetaDataVersion = 2i32;
    const SequenceNumber = 4i32; const Timestamp = 8i32; const Status = 16i32; }
}
impl opcua::types::BinaryEncodable for JsonDataSetMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for JsonDataSetMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for JsonDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for JsonDataSetMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for JsonDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for JsonDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonNetworkMessageContentMask :
    i32 { const None = 0i32; const NetworkMessageHeader = 1i32; const
    DataSetMessageHeader = 2i32; const SingleDataSetMessage = 4i32; const PublisherId =
    8i32; const DataSetClassId = 16i32; const ReplyTo = 32i32; }
}
impl opcua::types::BinaryEncodable for JsonNetworkMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for JsonNetworkMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for JsonNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for JsonNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for JsonNetworkMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for JsonNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for JsonNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MessageSecurityMode {
    Invalid = 0i32,
    None = 1i32,
    Sign = 2i32,
    SignAndEncrypt = 3i32,
}
impl Default for MessageSecurityMode {
    fn default() -> Self {
        Self::Invalid
    }
}
impl TryFrom<i32> for MessageSecurityMode {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Invalid,
            1i32 => Self::None,
            2i32 => Self::Sign,
            3i32 => Self::SignAndEncrypt,
            r => {
                log::warn!(
                        "Got unexpected value for enum MessageSecurityMode: {}. Falling back on Invalid",
                        r
                    );
                Self::Invalid
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for MessageSecurityMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum MessageSecurityMode: {}", e))?)
    }
}
impl From<MessageSecurityMode> for i32 {
    fn from(value: MessageSecurityMode) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for MessageSecurityMode {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for MessageSecurityMode {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for MessageSecurityMode {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for MessageSecurityMode {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for MessageSecurityMode {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ModelChangeStructureVerbMask {
    NodeAdded = 1i32,
    NodeDeleted = 2i32,
    ReferenceAdded = 4i32,
    ReferenceDeleted = 8i32,
    DataTypeChanged = 16i32,
}
impl TryFrom<i32> for ModelChangeStructureVerbMask {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::NodeAdded,
            2i32 => Self::NodeDeleted,
            4i32 => Self::ReferenceAdded,
            8i32 => Self::ReferenceDeleted,
            16i32 => Self::DataTypeChanged,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum ModelChangeStructureVerbMask: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ModelChangeStructureVerbMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum ModelChangeStructureVerbMask: {}",
                e
            )
        })?)
    }
}
impl From<ModelChangeStructureVerbMask> for i32 {
    fn from(value: ModelChangeStructureVerbMask) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for ModelChangeStructureVerbMask {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for ModelChangeStructureVerbMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for ModelChangeStructureVerbMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for ModelChangeStructureVerbMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for ModelChangeStructureVerbMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MonitoringMode {
    Disabled = 0i32,
    Sampling = 1i32,
    Reporting = 2i32,
}
impl Default for MonitoringMode {
    fn default() -> Self {
        Self::Disabled
    }
}
impl TryFrom<i32> for MonitoringMode {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Disabled,
            1i32 => Self::Sampling,
            2i32 => Self::Reporting,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum MonitoringMode: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for MonitoringMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum MonitoringMode: {}", e))?)
    }
}
impl From<MonitoringMode> for i32 {
    fn from(value: MonitoringMode) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for MonitoringMode {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for MonitoringMode {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for MonitoringMode {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for MonitoringMode {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for MonitoringMode {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NamingRuleType {
    Mandatory = 1i32,
    Optional = 2i32,
    Constraint = 3i32,
}
impl TryFrom<i32> for NamingRuleType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::Mandatory,
            2i32 => Self::Optional,
            3i32 => Self::Constraint,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum NamingRuleType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NamingRuleType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum NamingRuleType: {}", e))?)
    }
}
impl From<NamingRuleType> for i32 {
    fn from(value: NamingRuleType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for NamingRuleType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for NamingRuleType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for NamingRuleType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for NamingRuleType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for NamingRuleType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeAttributesMask {
    None = 0i32,
    AccessLevel = 1i32,
    ArrayDimensions = 2i32,
    BrowseName = 4i32,
    ContainsNoLoops = 8i32,
    DataType = 16i32,
    Description = 32i32,
    DisplayName = 64i32,
    EventNotifier = 128i32,
    Executable = 256i32,
    Historizing = 512i32,
    InverseName = 1024i32,
    IsAbstract = 2048i32,
    MinimumSamplingInterval = 4096i32,
    NodeClass = 8192i32,
    NodeId = 16384i32,
    Symmetric = 32768i32,
    UserAccessLevel = 65536i32,
    UserExecutable = 131072i32,
    UserWriteMask = 262144i32,
    ValueRank = 524288i32,
    WriteMask = 1048576i32,
    Value = 2097152i32,
    DataTypeDefinition = 4194304i32,
    RolePermissions = 8388608i32,
    AccessRestrictions = 16777216i32,
    All = 33554431i32,
    BaseNode = 26501220i32,
    Object = 26501348i32,
    ObjectType = 26503268i32,
    Variable = 26571383i32,
    VariableType = 28600438i32,
    Method = 26632548i32,
    ReferenceType = 26537060i32,
    View = 26501356i32,
}
impl Default for NodeAttributesMask {
    fn default() -> Self {
        Self::None
    }
}
impl TryFrom<i32> for NodeAttributesMask {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::None,
            1i32 => Self::AccessLevel,
            2i32 => Self::ArrayDimensions,
            4i32 => Self::BrowseName,
            8i32 => Self::ContainsNoLoops,
            16i32 => Self::DataType,
            32i32 => Self::Description,
            64i32 => Self::DisplayName,
            128i32 => Self::EventNotifier,
            256i32 => Self::Executable,
            512i32 => Self::Historizing,
            1024i32 => Self::InverseName,
            2048i32 => Self::IsAbstract,
            4096i32 => Self::MinimumSamplingInterval,
            8192i32 => Self::NodeClass,
            16384i32 => Self::NodeId,
            32768i32 => Self::Symmetric,
            65536i32 => Self::UserAccessLevel,
            131072i32 => Self::UserExecutable,
            262144i32 => Self::UserWriteMask,
            524288i32 => Self::ValueRank,
            1048576i32 => Self::WriteMask,
            2097152i32 => Self::Value,
            4194304i32 => Self::DataTypeDefinition,
            8388608i32 => Self::RolePermissions,
            16777216i32 => Self::AccessRestrictions,
            33554431i32 => Self::All,
            26501220i32 => Self::BaseNode,
            26501348i32 => Self::Object,
            26503268i32 => Self::ObjectType,
            26571383i32 => Self::Variable,
            28600438i32 => Self::VariableType,
            26632548i32 => Self::Method,
            26537060i32 => Self::ReferenceType,
            26501356i32 => Self::View,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum NodeAttributesMask: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeAttributesMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum NodeAttributesMask: {}", e))?)
    }
}
impl From<NodeAttributesMask> for i32 {
    fn from(value: NodeAttributesMask) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for NodeAttributesMask {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for NodeAttributesMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for NodeAttributesMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for NodeAttributesMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for NodeAttributesMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeClass {
    Unspecified = 0i32,
    Object = 1i32,
    Variable = 2i32,
    Method = 4i32,
    ObjectType = 8i32,
    VariableType = 16i32,
    ReferenceType = 32i32,
    DataType = 64i32,
    View = 128i32,
}
impl Default for NodeClass {
    fn default() -> Self {
        Self::Unspecified
    }
}
impl TryFrom<i32> for NodeClass {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Unspecified,
            1i32 => Self::Object,
            2i32 => Self::Variable,
            4i32 => Self::Method,
            8i32 => Self::ObjectType,
            16i32 => Self::VariableType,
            32i32 => Self::ReferenceType,
            64i32 => Self::DataType,
            128i32 => Self::View,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum NodeClass: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeClass {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum NodeClass: {}", e))?)
    }
}
impl From<NodeClass> for i32 {
    fn from(value: NodeClass) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for NodeClass {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for NodeClass {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for NodeClass {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for NodeClass {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for NodeClass {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
///The possible encodings for a NodeId value.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NodeIdType {
    TwoByte = 0u8,
    FourByte = 1u8,
    Numeric = 2u8,
    String = 3u8,
    Guid = 4u8,
    ByteString = 5u8,
}
impl Default for NodeIdType {
    fn default() -> Self {
        Self::TwoByte
    }
}
impl TryFrom<u8> for NodeIdType {
    type Error = opcua::types::Error;
    fn try_from(value: u8) -> Result<Self, <Self as TryFrom<u8>>::Error> {
        Ok(match value {
            0u8 => Self::TwoByte,
            1u8 => Self::FourByte,
            2u8 => Self::Numeric,
            3u8 => Self::String,
            4u8 => Self::Guid,
            5u8 => Self::ByteString,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum NodeIdType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeIdType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum NodeIdType: {}", e))?)
    }
}
impl From<NodeIdType> for u8 {
    fn from(value: NodeIdType) -> Self {
        value as u8
    }
}
impl opcua::types::IntoVariant for NodeIdType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as u8).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for NodeIdType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: u8 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize u8: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for NodeIdType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as u8)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for NodeIdType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        1usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, *self as u8)
    }
}
impl opcua::types::BinaryDecodable for NodeIdType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_u8(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OpenFileMode {
    Read = 1i32,
    Write = 2i32,
    EraseExisting = 4i32,
    Append = 8i32,
}
impl TryFrom<i32> for OpenFileMode {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::Read,
            2i32 => Self::Write,
            4i32 => Self::EraseExisting,
            8i32 => Self::Append,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum OpenFileMode: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for OpenFileMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum OpenFileMode: {}", e))?)
    }
}
impl From<OpenFileMode> for i32 {
    fn from(value: OpenFileMode) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for OpenFileMode {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for OpenFileMode {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for OpenFileMode {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for OpenFileMode {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for OpenFileMode {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OverrideValueHandling {
    Disabled = 0i32,
    LastUsableValue = 1i32,
    OverrideValue = 2i32,
}
impl Default for OverrideValueHandling {
    fn default() -> Self {
        Self::Disabled
    }
}
impl TryFrom<i32> for OverrideValueHandling {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Disabled,
            1i32 => Self::LastUsableValue,
            2i32 => Self::OverrideValue,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum OverrideValueHandling: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for OverrideValueHandling {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum OverrideValueHandling: {}", e))?)
    }
}
impl From<OverrideValueHandling> for i32 {
    fn from(value: OverrideValueHandling) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for OverrideValueHandling {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for OverrideValueHandling {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for OverrideValueHandling {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for OverrideValueHandling {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for OverrideValueHandling {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PerformUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Remove = 4i32,
}
impl TryFrom<i32> for PerformUpdateType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::Insert,
            2i32 => Self::Replace,
            3i32 => Self::Update,
            4i32 => Self::Remove,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum PerformUpdateType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PerformUpdateType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum PerformUpdateType: {}", e))?)
    }
}
impl From<PerformUpdateType> for i32 {
    fn from(value: PerformUpdateType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for PerformUpdateType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PerformUpdateType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PerformUpdateType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for PerformUpdateType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PerformUpdateType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PermissionType : i32 { const None
    = 0i32; const Browse = 1i32; const ReadRolePermissions = 2i32; const WriteAttribute =
    4i32; const WriteRolePermissions = 8i32; const WriteHistorizing = 16i32; const Read =
    32i32; const Write = 64i32; const ReadHistory = 128i32; const InsertHistory = 256i32;
    const ModifyHistory = 512i32; const DeleteHistory = 1024i32; const ReceiveEvents =
    2048i32; const Call = 4096i32; const AddReference = 8192i32; const RemoveReference =
    16384i32; const DeleteNode = 32768i32; const AddNode = 65536i32; }
}
impl opcua::types::BinaryEncodable for PermissionType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for PermissionType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for PermissionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for PermissionType {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PermissionType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PermissionType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PermissionType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubDiagnosticsCounterClassification {
    Information = 0i32,
    Error = 1i32,
}
impl Default for PubSubDiagnosticsCounterClassification {
    fn default() -> Self {
        Self::Information
    }
}
impl TryFrom<i32> for PubSubDiagnosticsCounterClassification {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Information,
            1i32 => Self::Error,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum PubSubDiagnosticsCounterClassification: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PubSubDiagnosticsCounterClassification {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PubSubDiagnosticsCounterClassification: {}",
                e
            )
        })?)
    }
}
impl From<PubSubDiagnosticsCounterClassification> for i32 {
    fn from(value: PubSubDiagnosticsCounterClassification) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for PubSubDiagnosticsCounterClassification {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PubSubDiagnosticsCounterClassification {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PubSubDiagnosticsCounterClassification {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for PubSubDiagnosticsCounterClassification {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PubSubDiagnosticsCounterClassification {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubState {
    Disabled = 0i32,
    Paused = 1i32,
    Operational = 2i32,
    Error = 3i32,
}
impl Default for PubSubState {
    fn default() -> Self {
        Self::Disabled
    }
}
impl TryFrom<i32> for PubSubState {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Disabled,
            1i32 => Self::Paused,
            2i32 => Self::Operational,
            3i32 => Self::Error,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum PubSubState: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PubSubState {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum PubSubState: {}", e))?)
    }
}
impl From<PubSubState> for i32 {
    fn from(value: PubSubState) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for PubSubState {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for PubSubState {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for PubSubState {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for PubSubState {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PubSubState {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundancySupport {
    None = 0i32,
    Cold = 1i32,
    Warm = 2i32,
    Hot = 3i32,
    Transparent = 4i32,
    HotAndMirrored = 5i32,
}
impl Default for RedundancySupport {
    fn default() -> Self {
        Self::None
    }
}
impl TryFrom<i32> for RedundancySupport {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::None,
            1i32 => Self::Cold,
            2i32 => Self::Warm,
            3i32 => Self::Hot,
            4i32 => Self::Transparent,
            5i32 => Self::HotAndMirrored,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum RedundancySupport: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for RedundancySupport {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum RedundancySupport: {}", e))?)
    }
}
impl From<RedundancySupport> for i32 {
    fn from(value: RedundancySupport) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for RedundancySupport {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for RedundancySupport {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for RedundancySupport {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for RedundancySupport {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for RedundancySupport {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SecurityTokenRequestType {
    Issue = 0i32,
    Renew = 1i32,
}
impl Default for SecurityTokenRequestType {
    fn default() -> Self {
        Self::Issue
    }
}
impl TryFrom<i32> for SecurityTokenRequestType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Issue,
            1i32 => Self::Renew,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum SecurityTokenRequestType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for SecurityTokenRequestType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum SecurityTokenRequestType: {}",
                e
            )
        })?)
    }
}
impl From<SecurityTokenRequestType> for i32 {
    fn from(value: SecurityTokenRequestType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for SecurityTokenRequestType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for SecurityTokenRequestType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for SecurityTokenRequestType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for SecurityTokenRequestType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for SecurityTokenRequestType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ServerState {
    Running = 0i32,
    Failed = 1i32,
    NoConfiguration = 2i32,
    Suspended = 3i32,
    Shutdown = 4i32,
    Test = 5i32,
    CommunicationFault = 6i32,
    Unknown = 7i32,
}
impl Default for ServerState {
    fn default() -> Self {
        Self::Running
    }
}
impl TryFrom<i32> for ServerState {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Running,
            1i32 => Self::Failed,
            2i32 => Self::NoConfiguration,
            3i32 => Self::Suspended,
            4i32 => Self::Shutdown,
            5i32 => Self::Test,
            6i32 => Self::CommunicationFault,
            7i32 => Self::Unknown,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum ServerState: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ServerState {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum ServerState: {}", e))?)
    }
}
impl From<ServerState> for i32 {
    fn from(value: ServerState) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for ServerState {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for ServerState {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for ServerState {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for ServerState {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for ServerState {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum StructureType {
    Structure = 0i32,
    StructureWithOptionalFields = 1i32,
    Union = 2i32,
}
impl Default for StructureType {
    fn default() -> Self {
        Self::Structure
    }
}
impl TryFrom<i32> for StructureType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Structure,
            1i32 => Self::StructureWithOptionalFields,
            2i32 => Self::Union,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum StructureType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for StructureType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum StructureType: {}", e))?)
    }
}
impl From<StructureType> for i32 {
    fn from(value: StructureType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for StructureType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for StructureType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for StructureType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for StructureType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for StructureType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TimestampsToReturn {
    Source = 0i32,
    Server = 1i32,
    Both = 2i32,
    Neither = 3i32,
    Invalid = 4i32,
}
impl Default for TimestampsToReturn {
    fn default() -> Self {
        Self::Source
    }
}
impl TryFrom<i32> for TimestampsToReturn {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Source,
            1i32 => Self::Server,
            2i32 => Self::Both,
            3i32 => Self::Neither,
            4i32 => Self::Invalid,
            r => {
                log::warn!(
                    "Got unexpected value for enum TimestampsToReturn: {}. Falling back on Invalid",
                    r
                );
                Self::Invalid
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for TimestampsToReturn {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum TimestampsToReturn: {}", e))?)
    }
}
impl From<TimestampsToReturn> for i32 {
    fn from(value: TimestampsToReturn) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for TimestampsToReturn {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for TimestampsToReturn {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for TimestampsToReturn {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for TimestampsToReturn {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for TimestampsToReturn {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TrustListMasks {
    None = 0i32,
    TrustedCertificates = 1i32,
    TrustedCrls = 2i32,
    IssuerCertificates = 4i32,
    IssuerCrls = 8i32,
    All = 15i32,
}
impl Default for TrustListMasks {
    fn default() -> Self {
        Self::None
    }
}
impl TryFrom<i32> for TrustListMasks {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::None,
            1i32 => Self::TrustedCertificates,
            2i32 => Self::TrustedCrls,
            4i32 => Self::IssuerCertificates,
            8i32 => Self::IssuerCrls,
            15i32 => Self::All,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum TrustListMasks: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for TrustListMasks {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum TrustListMasks: {}", e))?)
    }
}
impl From<TrustListMasks> for i32 {
    fn from(value: TrustListMasks) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for TrustListMasks {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for TrustListMasks {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for TrustListMasks {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for TrustListMasks {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for TrustListMasks {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpDataSetMessageContentMask :
    i32 { const None = 0i32; const Timestamp = 1i32; const PicoSeconds = 2i32; const
    Status = 4i32; const MajorVersion = 8i32; const MinorVersion = 16i32; const
    SequenceNumber = 32i32; }
}
impl opcua::types::BinaryEncodable for UadpDataSetMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for UadpDataSetMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for UadpDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpDataSetMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UadpDataSetMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UadpDataSetMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UadpDataSetMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpNetworkMessageContentMask :
    i32 { const None = 0i32; const PublisherId = 1i32; const GroupHeader = 2i32; const
    WriterGroupId = 4i32; const GroupVersion = 8i32; const NetworkMessageNumber = 16i32;
    const SequenceNumber = 32i32; const PayloadHeader = 64i32; const Timestamp = 128i32;
    const PicoSeconds = 256i32; const DataSetClassId = 512i32; const PromotedFields =
    1024i32; }
}
impl opcua::types::BinaryEncodable for UadpNetworkMessageContentMask {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
}
impl opcua::types::BinaryDecodable for UadpNetworkMessageContentMask {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, ctx)?))
    }
}
impl Default for UadpNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl opcua::types::IntoVariant for UadpNetworkMessageContentMask {
    fn into_variant(self) -> opcua::types::Variant {
        self.bits().into_variant()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UadpNetworkMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UadpNetworkMessageContentMask {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        Ok(Self::from_bits_truncate(stream.next_number()??))
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UadpNetworkMessageContentMask {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(self.bits())?;
        Ok(())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum UserTokenType {
    Anonymous = 0i32,
    UserName = 1i32,
    Certificate = 2i32,
    IssuedToken = 3i32,
}
impl Default for UserTokenType {
    fn default() -> Self {
        Self::Anonymous
    }
}
impl TryFrom<i32> for UserTokenType {
    type Error = opcua::types::Error;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::Anonymous,
            1i32 => Self::UserName,
            2i32 => Self::Certificate,
            3i32 => Self::IssuedToken,
            r => {
                return Err(opcua::types::Error::decoding(format!(
                    "Got unexpected value for enum UserTokenType: {}",
                    r
                )));
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UserTokenType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum UserTokenType: {}", e))?)
    }
}
impl From<UserTokenType> for i32 {
    fn from(value: UserTokenType) -> Self {
        value as i32
    }
}
impl opcua::types::IntoVariant for UserTokenType {
    fn into_variant(self) -> opcua::types::Variant {
        (self as i32).into_variant()
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonDecodable for UserTokenType {
    fn decode(
        stream: &mut opcua::types::json::JsonStreamReader<&mut dyn std::io::Read>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        use opcua::types::json::JsonReader;
        let value: i32 = stream.next_number()??;
        Self::try_from(value).map_err(|e| {
            opcua::types::Error::decoding(format!("Failed to deserialize i32: {:?}", e))
        })
    }
}
#[cfg(feature = "json")]
impl opcua::types::json::JsonEncodable for UserTokenType {
    fn encode(
        &self,
        stream: &mut opcua::types::json::JsonStreamWriter<&mut dyn std::io::Write>,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<()> {
        use opcua::types::json::JsonWriter;
        stream.number_value(*self as i32)?;
        Ok(())
    }
}
impl opcua::types::BinaryEncodable for UserTokenType {
    fn byte_len(&self, _ctx: &opcua::types::Context<'_>) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for UserTokenType {
    fn decode<S: std::io::Read + ?Sized>(
        stream: &mut S,
        _ctx: &opcua::types::Context<'_>,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Self::try_from(value)
    }
}
