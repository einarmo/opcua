// This file was autogenerated from schemas/1.0.4/Opc.Ua.Types.bsd by opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Adam Lock, Einar Omang
#[allow(unused)]
mod opcua { pub use crate as types; }
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelExType : i32 { const
    None = 0i32; const CurrentRead = 1i32; const CurrentWrite = 2i32; const HistoryRead =
    4i32; const HistoryWrite = 8i32; const SemanticChange = 16i32; const StatusWrite =
    32i32; const TimestampWrite = 64i32; const NonatomicRead = 256i32; const
    NonatomicWrite = 512i32; const WriteFullArrayOnly = 1024i32; const NoSubDataTypes =
    2048i32; }
}
impl opcua::types::BinaryEncodable for AccessLevelExType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for AccessLevelExType {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AccessLevelExType> for opcua::types::Variant {
    fn from(v: AccessLevelExType) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for AccessLevelExType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessLevelExType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for AccessLevelExType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(AccessLevelExType::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for AccessLevelExType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelType : u8 { const None
    = 0u8; const CurrentRead = 1u8; const CurrentWrite = 2u8; const HistoryRead = 4u8;
    const HistoryWrite = 8u8; const SemanticChange = 16u8; const StatusWrite = 32u8;
    const TimestampWrite = 64u8; }
}
impl opcua::types::BinaryEncodable for AccessLevelType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, decoding_options)?))
    }
}
impl Default for AccessLevelType {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AccessLevelType> for opcua::types::Variant {
    fn from(v: AccessLevelType) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for AccessLevelType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessLevelType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for AccessLevelType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = u8;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an u8")
            }
        }
        deserializer
            .deserialize_u8(BitFieldVisitor)
            .map(AccessLevelType::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for AccessLevelType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_u8(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessRestrictionType : i16 {
    const None = 0i16; const SigningRequired = 1i16; const EncryptionRequired = 2i16;
    const SessionRequired = 4i16; const ApplyRestrictionsToBrowse = 8i16; }
}
impl opcua::types::BinaryEncodable for AccessRestrictionType {
    fn byte_len(&self) -> usize {
        2usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, decoding_options)?))
    }
}
impl Default for AccessRestrictionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AccessRestrictionType> for opcua::types::Variant {
    fn from(v: AccessRestrictionType) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for AccessRestrictionType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AccessRestrictionType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i16::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for AccessRestrictionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i16;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i16")
            }
        }
        deserializer
            .deserialize_i16(BitFieldVisitor)
            .map(AccessRestrictionType::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for AccessRestrictionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i16(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ApplicationType {
    Server = 0i32,
    Client = 1i32,
    ClientAndServer = 2i32,
    DiscoveryServer = 3i32,
}
impl TryFrom<i32> for ApplicationType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Server,
                1i32 => Self::Client,
                2i32 => Self::ClientAndServer,
                3i32 => Self::DiscoveryServer,
                r => {
                    log::error!("Got unexpected value for enum ApplicationType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ApplicationType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum ApplicationType: {}", e)
                })?,
        )
    }
}
impl From<ApplicationType> for i32 {
    fn from(value: ApplicationType) -> Self {
        value as i32
    }
}
impl From<ApplicationType> for opcua::types::Variant {
    fn from(value: ApplicationType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for ApplicationType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for ApplicationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for ApplicationType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for ApplicationType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AttributeWriteMask : i32 { const
    None = 0i32; const AccessLevel = 1i32; const ArrayDimensions = 2i32; const BrowseName
    = 4i32; const ContainsNoLoops = 8i32; const DataType = 16i32; const Description =
    32i32; const DisplayName = 64i32; const EventNotifier = 128i32; const Executable =
    256i32; const Historizing = 512i32; const InverseName = 1024i32; const IsAbstract =
    2048i32; const MinimumSamplingInterval = 4096i32; const NodeClass = 8192i32; const
    NodeId = 16384i32; const Symmetric = 32768i32; const UserAccessLevel = 65536i32;
    const UserExecutable = 131072i32; const UserWriteMask = 262144i32; const ValueRank =
    524288i32; const WriteMask = 1048576i32; const ValueForVariableType = 2097152i32;
    const DataTypeDefinition = 4194304i32; const RolePermissions = 8388608i32; const
    AccessRestrictions = 16777216i32; const AccessLevelEx = 33554432i32; }
}
impl opcua::types::BinaryEncodable for AttributeWriteMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for AttributeWriteMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<AttributeWriteMask> for opcua::types::Variant {
    fn from(v: AttributeWriteMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for AttributeWriteMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AttributeWriteMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for AttributeWriteMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(AttributeWriteMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for AttributeWriteMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum AxisScaleEnumeration {
    Linear = 0i32,
    Log = 1i32,
    Ln = 2i32,
}
impl TryFrom<i32> for AxisScaleEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Linear,
                1i32 => Self::Log,
                2i32 => Self::Ln,
                r => {
                    log::error!(
                        "Got unexpected value for enum AxisScaleEnumeration: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for AxisScaleEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum AxisScaleEnumeration: {}", e)
                })?,
        )
    }
}
impl From<AxisScaleEnumeration> for i32 {
    fn from(value: AxisScaleEnumeration) -> Self {
        value as i32
    }
}
impl From<AxisScaleEnumeration> for opcua::types::Variant {
    fn from(value: AxisScaleEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for AxisScaleEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for AxisScaleEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for AxisScaleEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for AxisScaleEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrokerTransportQualityOfService {
    NotSpecified = 0i32,
    BestEffort = 1i32,
    AtLeastOnce = 2i32,
    AtMostOnce = 3i32,
    ExactlyOnce = 4i32,
}
impl TryFrom<i32> for BrokerTransportQualityOfService {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::NotSpecified,
                1i32 => Self::BestEffort,
                2i32 => Self::AtLeastOnce,
                3i32 => Self::AtMostOnce,
                4i32 => Self::ExactlyOnce,
                r => {
                    log::error!(
                        "Got unexpected value for enum BrokerTransportQualityOfService: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrokerTransportQualityOfService {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!(
                        "Got unexpected value for enum BrokerTransportQualityOfService: {}",
                        e
                    )
                })?,
        )
    }
}
impl From<BrokerTransportQualityOfService> for i32 {
    fn from(value: BrokerTransportQualityOfService) -> Self {
        value as i32
    }
}
impl From<BrokerTransportQualityOfService> for opcua::types::Variant {
    fn from(value: BrokerTransportQualityOfService) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for BrokerTransportQualityOfService {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for BrokerTransportQualityOfService {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for BrokerTransportQualityOfService {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for BrokerTransportQualityOfService {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseDirection {
    Forward = 0i32,
    Inverse = 1i32,
    Both = 2i32,
    Invalid = 3i32,
}
impl TryFrom<i32> for BrowseDirection {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Forward,
                1i32 => Self::Inverse,
                2i32 => Self::Both,
                3i32 => Self::Invalid,
                r => {
                    log::warn!(
                        "Got unexpected value for enum BrowseDirection: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrowseDirection {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum BrowseDirection: {}", e)
                })?,
        )
    }
}
impl From<BrowseDirection> for i32 {
    fn from(value: BrowseDirection) -> Self {
        value as i32
    }
}
impl From<BrowseDirection> for opcua::types::Variant {
    fn from(value: BrowseDirection) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for BrowseDirection {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for BrowseDirection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for BrowseDirection {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for BrowseDirection {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseResultMask {
    None = 0i32,
    ReferenceTypeId = 1i32,
    IsForward = 2i32,
    NodeClass = 4i32,
    BrowseName = 8i32,
    DisplayName = 16i32,
    TypeDefinition = 32i32,
    All = 63i32,
    ReferenceTypeInfo = 3i32,
    TargetInfo = 60i32,
}
impl TryFrom<i32> for BrowseResultMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::ReferenceTypeId,
                2i32 => Self::IsForward,
                4i32 => Self::NodeClass,
                8i32 => Self::BrowseName,
                16i32 => Self::DisplayName,
                32i32 => Self::TypeDefinition,
                63i32 => Self::All,
                3i32 => Self::ReferenceTypeInfo,
                60i32 => Self::TargetInfo,
                r => {
                    log::error!("Got unexpected value for enum BrowseResultMask: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for BrowseResultMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum BrowseResultMask: {}", e)
                })?,
        )
    }
}
impl From<BrowseResultMask> for i32 {
    fn from(value: BrowseResultMask) -> Self {
        value as i32
    }
}
impl From<BrowseResultMask> for opcua::types::Variant {
    fn from(value: BrowseResultMask) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for BrowseResultMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for BrowseResultMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for BrowseResultMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for BrowseResultMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataChangeTrigger {
    Status = 0i32,
    StatusValue = 1i32,
    StatusValueTimestamp = 2i32,
}
impl TryFrom<i32> for DataChangeTrigger {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Status,
                1i32 => Self::StatusValue,
                2i32 => Self::StatusValueTimestamp,
                r => {
                    log::error!(
                        "Got unexpected value for enum DataChangeTrigger: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataChangeTrigger {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum DataChangeTrigger: {}", e)
                })?,
        )
    }
}
impl From<DataChangeTrigger> for i32 {
    fn from(value: DataChangeTrigger) -> Self {
        value as i32
    }
}
impl From<DataChangeTrigger> for opcua::types::Variant {
    fn from(value: DataChangeTrigger) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for DataChangeTrigger {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DataChangeTrigger {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DataChangeTrigger {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for DataChangeTrigger {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldContentMask : i32 {
    const None = 0i32; const StatusCode = 1i32; const SourceTimestamp = 2i32; const
    ServerTimestamp = 4i32; const SourcePicoSeconds = 8i32; const ServerPicoSeconds =
    16i32; const RawData = 32i32; }
}
impl opcua::types::BinaryEncodable for DataSetFieldContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for DataSetFieldContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DataSetFieldContentMask> for opcua::types::Variant {
    fn from(v: DataSetFieldContentMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for DataSetFieldContentMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetFieldContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DataSetFieldContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(DataSetFieldContentMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DataSetFieldContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldFlags : i16 { const
    None = 0i16; const PromotedField = 1i16; }
}
impl opcua::types::BinaryEncodable for DataSetFieldFlags {
    fn byte_len(&self) -> usize {
        2usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, decoding_options)?))
    }
}
impl Default for DataSetFieldFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<DataSetFieldFlags> for opcua::types::Variant {
    fn from(v: DataSetFieldFlags) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for DataSetFieldFlags {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetFieldFlags {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i16::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DataSetFieldFlags {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i16;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i16")
            }
        }
        deserializer
            .deserialize_i16(BitFieldVisitor)
            .map(DataSetFieldFlags::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DataSetFieldFlags {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i16(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataSetOrderingType {
    Undefined = 0i32,
    AscendingWriterId = 1i32,
    AscendingWriterIdSingle = 2i32,
}
impl TryFrom<i32> for DataSetOrderingType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Undefined,
                1i32 => Self::AscendingWriterId,
                2i32 => Self::AscendingWriterIdSingle,
                r => {
                    log::error!(
                        "Got unexpected value for enum DataSetOrderingType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DataSetOrderingType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum DataSetOrderingType: {}", e)
                })?,
        )
    }
}
impl From<DataSetOrderingType> for i32 {
    fn from(value: DataSetOrderingType) -> Self {
        value as i32
    }
}
impl From<DataSetOrderingType> for opcua::types::Variant {
    fn from(value: DataSetOrderingType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for DataSetOrderingType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DataSetOrderingType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DataSetOrderingType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for DataSetOrderingType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DeadbandType {
    None = 0i32,
    Absolute = 1i32,
    Percent = 2i32,
}
impl TryFrom<i32> for DeadbandType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::Absolute,
                2i32 => Self::Percent,
                r => {
                    log::error!("Got unexpected value for enum DeadbandType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DeadbandType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum DeadbandType: {}", e)
                })?,
        )
    }
}
impl From<DeadbandType> for i32 {
    fn from(value: DeadbandType) -> Self {
        value as i32
    }
}
impl From<DeadbandType> for opcua::types::Variant {
    fn from(value: DeadbandType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for DeadbandType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DeadbandType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DeadbandType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for DeadbandType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DiagnosticsLevel {
    Basic = 0i32,
    Advanced = 1i32,
    Info = 2i32,
    Log = 3i32,
    Debug = 4i32,
}
impl TryFrom<i32> for DiagnosticsLevel {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Basic,
                1i32 => Self::Advanced,
                2i32 => Self::Info,
                3i32 => Self::Log,
                4i32 => Self::Debug,
                r => {
                    log::error!("Got unexpected value for enum DiagnosticsLevel: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for DiagnosticsLevel {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum DiagnosticsLevel: {}", e)
                })?,
        )
    }
}
impl From<DiagnosticsLevel> for i32 {
    fn from(value: DiagnosticsLevel) -> Self {
        value as i32
    }
}
impl From<DiagnosticsLevel> for opcua::types::Variant {
    fn from(value: DiagnosticsLevel) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for DiagnosticsLevel {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for DiagnosticsLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for DiagnosticsLevel {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for DiagnosticsLevel {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct EventNotifierType : u8 { const
    None = 0u8; const SubscribeToEvents = 1u8; const HistoryRead = 4u8; const
    HistoryWrite = 8u8; }
}
impl opcua::types::BinaryEncodable for EventNotifierType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, decoding_options)?))
    }
}
impl Default for EventNotifierType {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<EventNotifierType> for opcua::types::Variant {
    fn from(v: EventNotifierType) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for EventNotifierType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for EventNotifierType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for EventNotifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = u8;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an u8")
            }
        }
        deserializer
            .deserialize_u8(BitFieldVisitor)
            .map(EventNotifierType::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for EventNotifierType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_u8(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ExceptionDeviationFormat {
    AbsoluteValue = 0i32,
    PercentOfValue = 1i32,
    PercentOfRange = 2i32,
    PercentOfEURange = 3i32,
    Unknown = 4i32,
}
impl TryFrom<i32> for ExceptionDeviationFormat {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::AbsoluteValue,
                1i32 => Self::PercentOfValue,
                2i32 => Self::PercentOfRange,
                3i32 => Self::PercentOfEURange,
                4i32 => Self::Unknown,
                r => {
                    log::error!(
                        "Got unexpected value for enum ExceptionDeviationFormat: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ExceptionDeviationFormat {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!(
                        "Got unexpected value for enum ExceptionDeviationFormat: {}", e
                    )
                })?,
        )
    }
}
impl From<ExceptionDeviationFormat> for i32 {
    fn from(value: ExceptionDeviationFormat) -> Self {
        value as i32
    }
}
impl From<ExceptionDeviationFormat> for opcua::types::Variant {
    fn from(value: ExceptionDeviationFormat) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for ExceptionDeviationFormat {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for ExceptionDeviationFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for ExceptionDeviationFormat {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for ExceptionDeviationFormat {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum FilterOperator {
    Equals = 0i32,
    IsNull = 1i32,
    GreaterThan = 2i32,
    LessThan = 3i32,
    GreaterThanOrEqual = 4i32,
    LessThanOrEqual = 5i32,
    Like = 6i32,
    Not = 7i32,
    Between = 8i32,
    InList = 9i32,
    And = 10i32,
    Or = 11i32,
    Cast = 12i32,
    InView = 13i32,
    OfType = 14i32,
    RelatedTo = 15i32,
    BitwiseAnd = 16i32,
    BitwiseOr = 17i32,
}
impl TryFrom<i32> for FilterOperator {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Equals,
                1i32 => Self::IsNull,
                2i32 => Self::GreaterThan,
                3i32 => Self::LessThan,
                4i32 => Self::GreaterThanOrEqual,
                5i32 => Self::LessThanOrEqual,
                6i32 => Self::Like,
                7i32 => Self::Not,
                8i32 => Self::Between,
                9i32 => Self::InList,
                10i32 => Self::And,
                11i32 => Self::Or,
                12i32 => Self::Cast,
                13i32 => Self::InView,
                14i32 => Self::OfType,
                15i32 => Self::RelatedTo,
                16i32 => Self::BitwiseAnd,
                17i32 => Self::BitwiseOr,
                r => {
                    log::error!("Got unexpected value for enum FilterOperator: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for FilterOperator {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum FilterOperator: {}", e)
                })?,
        )
    }
}
impl From<FilterOperator> for i32 {
    fn from(value: FilterOperator) -> Self {
        value as i32
    }
}
impl From<FilterOperator> for opcua::types::Variant {
    fn from(value: FilterOperator) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for FilterOperator {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for FilterOperator {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for FilterOperator {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for FilterOperator {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum HistoryUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Delete = 4i32,
}
impl TryFrom<i32> for HistoryUpdateType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Insert,
                2i32 => Self::Replace,
                3i32 => Self::Update,
                4i32 => Self::Delete,
                r => {
                    log::error!(
                        "Got unexpected value for enum HistoryUpdateType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for HistoryUpdateType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum HistoryUpdateType: {}", e)
                })?,
        )
    }
}
impl From<HistoryUpdateType> for i32 {
    fn from(value: HistoryUpdateType) -> Self {
        value as i32
    }
}
impl From<HistoryUpdateType> for opcua::types::Variant {
    fn from(value: HistoryUpdateType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for HistoryUpdateType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for HistoryUpdateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for HistoryUpdateType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for HistoryUpdateType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdentityCriteriaType {
    UserName = 1i32,
    Thumbprint = 2i32,
    Role = 3i32,
    GroupId = 4i32,
    Anonymous = 5i32,
    AuthenticatedUser = 6i32,
}
impl TryFrom<i32> for IdentityCriteriaType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::UserName,
                2i32 => Self::Thumbprint,
                3i32 => Self::Role,
                4i32 => Self::GroupId,
                5i32 => Self::Anonymous,
                6i32 => Self::AuthenticatedUser,
                r => {
                    log::error!(
                        "Got unexpected value for enum IdentityCriteriaType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for IdentityCriteriaType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum IdentityCriteriaType: {}", e)
                })?,
        )
    }
}
impl From<IdentityCriteriaType> for i32 {
    fn from(value: IdentityCriteriaType) -> Self {
        value as i32
    }
}
impl From<IdentityCriteriaType> for opcua::types::Variant {
    fn from(value: IdentityCriteriaType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for IdentityCriteriaType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for IdentityCriteriaType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for IdentityCriteriaType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for IdentityCriteriaType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdType {
    Numeric = 0i32,
    String = 1i32,
    Guid = 2i32,
    Opaque = 3i32,
}
impl TryFrom<i32> for IdType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Numeric,
                1i32 => Self::String,
                2i32 => Self::Guid,
                3i32 => Self::Opaque,
                r => {
                    log::error!("Got unexpected value for enum IdType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for IdType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| format!("Got unexpected value for enum IdType: {}", e))?,
        )
    }
}
impl From<IdType> for i32 {
    fn from(value: IdType) -> Self {
        value as i32
    }
}
impl From<IdType> for opcua::types::Variant {
    fn from(value: IdType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for IdType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for IdType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for IdType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for IdType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonDataSetMessageContentMask :
    i32 { const None = 0i32; const DataSetWriterId = 1i32; const MetaDataVersion = 2i32;
    const SequenceNumber = 4i32; const Timestamp = 8i32; const Status = 16i32; }
}
impl opcua::types::BinaryEncodable for JsonDataSetMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for JsonDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<JsonDataSetMessageContentMask> for opcua::types::Variant {
    fn from(v: JsonDataSetMessageContentMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for JsonDataSetMessageContentMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for JsonDataSetMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for JsonDataSetMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(JsonDataSetMessageContentMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for JsonDataSetMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonNetworkMessageContentMask :
    i32 { const None = 0i32; const NetworkMessageHeader = 1i32; const
    DataSetMessageHeader = 2i32; const SingleDataSetMessage = 4i32; const PublisherId =
    8i32; const DataSetClassId = 16i32; const ReplyTo = 32i32; }
}
impl opcua::types::BinaryEncodable for JsonNetworkMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for JsonNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<JsonNetworkMessageContentMask> for opcua::types::Variant {
    fn from(v: JsonNetworkMessageContentMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for JsonNetworkMessageContentMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for JsonNetworkMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for JsonNetworkMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(JsonNetworkMessageContentMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for JsonNetworkMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MessageSecurityMode {
    Invalid = 0i32,
    None = 1i32,
    Sign = 2i32,
    SignAndEncrypt = 3i32,
}
impl TryFrom<i32> for MessageSecurityMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Invalid,
                1i32 => Self::None,
                2i32 => Self::Sign,
                3i32 => Self::SignAndEncrypt,
                r => {
                    log::warn!(
                        "Got unexpected value for enum MessageSecurityMode: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for MessageSecurityMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum MessageSecurityMode: {}", e)
                })?,
        )
    }
}
impl From<MessageSecurityMode> for i32 {
    fn from(value: MessageSecurityMode) -> Self {
        value as i32
    }
}
impl From<MessageSecurityMode> for opcua::types::Variant {
    fn from(value: MessageSecurityMode) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for MessageSecurityMode {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for MessageSecurityMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for MessageSecurityMode {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for MessageSecurityMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ModelChangeStructureVerbMask {
    NodeAdded = 1i32,
    NodeDeleted = 2i32,
    ReferenceAdded = 4i32,
    ReferenceDeleted = 8i32,
    DataTypeChanged = 16i32,
}
impl TryFrom<i32> for ModelChangeStructureVerbMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::NodeAdded,
                2i32 => Self::NodeDeleted,
                4i32 => Self::ReferenceAdded,
                8i32 => Self::ReferenceDeleted,
                16i32 => Self::DataTypeChanged,
                r => {
                    log::error!(
                        "Got unexpected value for enum ModelChangeStructureVerbMask: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ModelChangeStructureVerbMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!(
                        "Got unexpected value for enum ModelChangeStructureVerbMask: {}",
                        e
                    )
                })?,
        )
    }
}
impl From<ModelChangeStructureVerbMask> for i32 {
    fn from(value: ModelChangeStructureVerbMask) -> Self {
        value as i32
    }
}
impl From<ModelChangeStructureVerbMask> for opcua::types::Variant {
    fn from(value: ModelChangeStructureVerbMask) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for ModelChangeStructureVerbMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for ModelChangeStructureVerbMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for ModelChangeStructureVerbMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for ModelChangeStructureVerbMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MonitoringMode {
    Disabled = 0i32,
    Sampling = 1i32,
    Reporting = 2i32,
}
impl TryFrom<i32> for MonitoringMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::Sampling,
                2i32 => Self::Reporting,
                r => {
                    log::error!("Got unexpected value for enum MonitoringMode: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for MonitoringMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum MonitoringMode: {}", e)
                })?,
        )
    }
}
impl From<MonitoringMode> for i32 {
    fn from(value: MonitoringMode) -> Self {
        value as i32
    }
}
impl From<MonitoringMode> for opcua::types::Variant {
    fn from(value: MonitoringMode) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for MonitoringMode {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for MonitoringMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for MonitoringMode {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for MonitoringMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NamingRuleType {
    Mandatory = 1i32,
    Optional = 2i32,
    Constraint = 3i32,
}
impl TryFrom<i32> for NamingRuleType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Mandatory,
                2i32 => Self::Optional,
                3i32 => Self::Constraint,
                r => {
                    log::error!("Got unexpected value for enum NamingRuleType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NamingRuleType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum NamingRuleType: {}", e)
                })?,
        )
    }
}
impl From<NamingRuleType> for i32 {
    fn from(value: NamingRuleType) -> Self {
        value as i32
    }
}
impl From<NamingRuleType> for opcua::types::Variant {
    fn from(value: NamingRuleType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for NamingRuleType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for NamingRuleType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for NamingRuleType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for NamingRuleType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeAttributesMask {
    None = 0i32,
    AccessLevel = 1i32,
    ArrayDimensions = 2i32,
    BrowseName = 4i32,
    ContainsNoLoops = 8i32,
    DataType = 16i32,
    Description = 32i32,
    DisplayName = 64i32,
    EventNotifier = 128i32,
    Executable = 256i32,
    Historizing = 512i32,
    InverseName = 1024i32,
    IsAbstract = 2048i32,
    MinimumSamplingInterval = 4096i32,
    NodeClass = 8192i32,
    NodeId = 16384i32,
    Symmetric = 32768i32,
    UserAccessLevel = 65536i32,
    UserExecutable = 131072i32,
    UserWriteMask = 262144i32,
    ValueRank = 524288i32,
    WriteMask = 1048576i32,
    Value = 2097152i32,
    DataTypeDefinition = 4194304i32,
    RolePermissions = 8388608i32,
    AccessRestrictions = 16777216i32,
    All = 33554431i32,
    BaseNode = 26501220i32,
    Object = 26501348i32,
    ObjectType = 26503268i32,
    Variable = 26571383i32,
    VariableType = 28600438i32,
    Method = 26632548i32,
    ReferenceType = 26537060i32,
    View = 26501356i32,
}
impl TryFrom<i32> for NodeAttributesMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::AccessLevel,
                2i32 => Self::ArrayDimensions,
                4i32 => Self::BrowseName,
                8i32 => Self::ContainsNoLoops,
                16i32 => Self::DataType,
                32i32 => Self::Description,
                64i32 => Self::DisplayName,
                128i32 => Self::EventNotifier,
                256i32 => Self::Executable,
                512i32 => Self::Historizing,
                1024i32 => Self::InverseName,
                2048i32 => Self::IsAbstract,
                4096i32 => Self::MinimumSamplingInterval,
                8192i32 => Self::NodeClass,
                16384i32 => Self::NodeId,
                32768i32 => Self::Symmetric,
                65536i32 => Self::UserAccessLevel,
                131072i32 => Self::UserExecutable,
                262144i32 => Self::UserWriteMask,
                524288i32 => Self::ValueRank,
                1048576i32 => Self::WriteMask,
                2097152i32 => Self::Value,
                4194304i32 => Self::DataTypeDefinition,
                8388608i32 => Self::RolePermissions,
                16777216i32 => Self::AccessRestrictions,
                33554431i32 => Self::All,
                26501220i32 => Self::BaseNode,
                26501348i32 => Self::Object,
                26503268i32 => Self::ObjectType,
                26571383i32 => Self::Variable,
                28600438i32 => Self::VariableType,
                26632548i32 => Self::Method,
                26537060i32 => Self::ReferenceType,
                26501356i32 => Self::View,
                r => {
                    log::error!(
                        "Got unexpected value for enum NodeAttributesMask: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeAttributesMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum NodeAttributesMask: {}", e)
                })?,
        )
    }
}
impl From<NodeAttributesMask> for i32 {
    fn from(value: NodeAttributesMask) -> Self {
        value as i32
    }
}
impl From<NodeAttributesMask> for opcua::types::Variant {
    fn from(value: NodeAttributesMask) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for NodeAttributesMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for NodeAttributesMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for NodeAttributesMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for NodeAttributesMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeClass {
    Unspecified = 0i32,
    Object = 1i32,
    Variable = 2i32,
    Method = 4i32,
    ObjectType = 8i32,
    VariableType = 16i32,
    ReferenceType = 32i32,
    DataType = 64i32,
    View = 128i32,
}
impl TryFrom<i32> for NodeClass {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Unspecified,
                1i32 => Self::Object,
                2i32 => Self::Variable,
                4i32 => Self::Method,
                8i32 => Self::ObjectType,
                16i32 => Self::VariableType,
                32i32 => Self::ReferenceType,
                64i32 => Self::DataType,
                128i32 => Self::View,
                r => {
                    log::error!("Got unexpected value for enum NodeClass: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeClass {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| format!("Got unexpected value for enum NodeClass: {}", e))?,
        )
    }
}
impl From<NodeClass> for i32 {
    fn from(value: NodeClass) -> Self {
        value as i32
    }
}
impl From<NodeClass> for opcua::types::Variant {
    fn from(value: NodeClass) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for NodeClass {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for NodeClass {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for NodeClass {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for NodeClass {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
///The possible encodings for a NodeId value.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NodeIdType {
    TwoByte = 0u8,
    FourByte = 1u8,
    Numeric = 2u8,
    String = 3u8,
    Guid = 4u8,
    ByteString = 5u8,
}
impl TryFrom<u8> for NodeIdType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: u8) -> Result<Self, <Self as TryFrom<u8>>::Error> {
        Ok(
            match value {
                0u8 => Self::TwoByte,
                1u8 => Self::FourByte,
                2u8 => Self::Numeric,
                3u8 => Self::String,
                4u8 => Self::Guid,
                5u8 => Self::ByteString,
                r => {
                    log::error!("Got unexpected value for enum NodeIdType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for NodeIdType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = u8::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| format!("Got unexpected value for enum NodeIdType: {}", e))?,
        )
    }
}
impl From<NodeIdType> for u8 {
    fn from(value: NodeIdType) -> Self {
        value as u8
    }
}
impl From<NodeIdType> for opcua::types::Variant {
    fn from(value: NodeIdType) -> Self {
        Self::from(value as u8)
    }
}
impl opcua::types::AsVariantRef for NodeIdType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as u8).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for NodeIdType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = u8;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "u8")
            }
        }
        let value = deserializer.deserialize_u8(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize u8: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for NodeIdType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_u8(*self as u8)
    }
}
impl opcua::types::BinaryEncodable for NodeIdType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, *self as u8)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_u8(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OpenFileMode {
    Read = 1i32,
    Write = 2i32,
    EraseExisting = 4i32,
    Append = 8i32,
}
impl TryFrom<i32> for OpenFileMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Read,
                2i32 => Self::Write,
                4i32 => Self::EraseExisting,
                8i32 => Self::Append,
                r => {
                    log::error!("Got unexpected value for enum OpenFileMode: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for OpenFileMode {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum OpenFileMode: {}", e)
                })?,
        )
    }
}
impl From<OpenFileMode> for i32 {
    fn from(value: OpenFileMode) -> Self {
        value as i32
    }
}
impl From<OpenFileMode> for opcua::types::Variant {
    fn from(value: OpenFileMode) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for OpenFileMode {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for OpenFileMode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for OpenFileMode {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for OpenFileMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OverrideValueHandling {
    Disabled = 0i32,
    LastUsableValue = 1i32,
    OverrideValue = 2i32,
}
impl TryFrom<i32> for OverrideValueHandling {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::LastUsableValue,
                2i32 => Self::OverrideValue,
                r => {
                    log::error!(
                        "Got unexpected value for enum OverrideValueHandling: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for OverrideValueHandling {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum OverrideValueHandling: {}", e)
                })?,
        )
    }
}
impl From<OverrideValueHandling> for i32 {
    fn from(value: OverrideValueHandling) -> Self {
        value as i32
    }
}
impl From<OverrideValueHandling> for opcua::types::Variant {
    fn from(value: OverrideValueHandling) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for OverrideValueHandling {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for OverrideValueHandling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for OverrideValueHandling {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for OverrideValueHandling {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PerformUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Remove = 4i32,
}
impl TryFrom<i32> for PerformUpdateType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Insert,
                2i32 => Self::Replace,
                3i32 => Self::Update,
                4i32 => Self::Remove,
                r => {
                    log::error!(
                        "Got unexpected value for enum PerformUpdateType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PerformUpdateType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum PerformUpdateType: {}", e)
                })?,
        )
    }
}
impl From<PerformUpdateType> for i32 {
    fn from(value: PerformUpdateType) -> Self {
        value as i32
    }
}
impl From<PerformUpdateType> for opcua::types::Variant {
    fn from(value: PerformUpdateType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PerformUpdateType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PerformUpdateType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PerformUpdateType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PerformUpdateType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PermissionType : i32 { const None
    = 0i32; const Browse = 1i32; const ReadRolePermissions = 2i32; const WriteAttribute =
    4i32; const WriteRolePermissions = 8i32; const WriteHistorizing = 16i32; const Read =
    32i32; const Write = 64i32; const ReadHistory = 128i32; const InsertHistory = 256i32;
    const ModifyHistory = 512i32; const DeleteHistory = 1024i32; const ReceiveEvents =
    2048i32; const Call = 4096i32; const AddReference = 8192i32; const RemoveReference =
    16384i32; const DeleteNode = 32768i32; const AddNode = 65536i32; }
}
impl opcua::types::BinaryEncodable for PermissionType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for PermissionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<PermissionType> for opcua::types::Variant {
    fn from(v: PermissionType) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for PermissionType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PermissionType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PermissionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(PermissionType::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PermissionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubDiagnosticsCounterClassification {
    Information = 0i32,
    Error = 1i32,
}
impl TryFrom<i32> for PubSubDiagnosticsCounterClassification {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Information,
                1i32 => Self::Error,
                r => {
                    log::error!(
                        "Got unexpected value for enum PubSubDiagnosticsCounterClassification: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PubSubDiagnosticsCounterClassification {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!(
                        "Got unexpected value for enum PubSubDiagnosticsCounterClassification: {}",
                        e
                    )
                })?,
        )
    }
}
impl From<PubSubDiagnosticsCounterClassification> for i32 {
    fn from(value: PubSubDiagnosticsCounterClassification) -> Self {
        value as i32
    }
}
impl From<PubSubDiagnosticsCounterClassification> for opcua::types::Variant {
    fn from(value: PubSubDiagnosticsCounterClassification) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PubSubDiagnosticsCounterClassification {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PubSubDiagnosticsCounterClassification {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PubSubDiagnosticsCounterClassification {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PubSubDiagnosticsCounterClassification {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubState {
    Disabled = 0i32,
    Paused = 1i32,
    Operational = 2i32,
    Error = 3i32,
}
impl TryFrom<i32> for PubSubState {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::Paused,
                2i32 => Self::Operational,
                3i32 => Self::Error,
                r => {
                    log::error!("Got unexpected value for enum PubSubState: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PubSubState {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum PubSubState: {}", e)
                })?,
        )
    }
}
impl From<PubSubState> for i32 {
    fn from(value: PubSubState) -> Self {
        value as i32
    }
}
impl From<PubSubState> for opcua::types::Variant {
    fn from(value: PubSubState) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PubSubState {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PubSubState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PubSubState {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PubSubState {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundancySupport {
    None = 0i32,
    Cold = 1i32,
    Warm = 2i32,
    Hot = 3i32,
    Transparent = 4i32,
    HotAndMirrored = 5i32,
}
impl TryFrom<i32> for RedundancySupport {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::Cold,
                2i32 => Self::Warm,
                3i32 => Self::Hot,
                4i32 => Self::Transparent,
                5i32 => Self::HotAndMirrored,
                r => {
                    log::error!(
                        "Got unexpected value for enum RedundancySupport: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for RedundancySupport {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum RedundancySupport: {}", e)
                })?,
        )
    }
}
impl From<RedundancySupport> for i32 {
    fn from(value: RedundancySupport) -> Self {
        value as i32
    }
}
impl From<RedundancySupport> for opcua::types::Variant {
    fn from(value: RedundancySupport) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for RedundancySupport {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for RedundancySupport {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for RedundancySupport {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for RedundancySupport {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SecurityTokenRequestType {
    Issue = 0i32,
    Renew = 1i32,
}
impl TryFrom<i32> for SecurityTokenRequestType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Issue,
                1i32 => Self::Renew,
                r => {
                    log::error!(
                        "Got unexpected value for enum SecurityTokenRequestType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for SecurityTokenRequestType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!(
                        "Got unexpected value for enum SecurityTokenRequestType: {}", e
                    )
                })?,
        )
    }
}
impl From<SecurityTokenRequestType> for i32 {
    fn from(value: SecurityTokenRequestType) -> Self {
        value as i32
    }
}
impl From<SecurityTokenRequestType> for opcua::types::Variant {
    fn from(value: SecurityTokenRequestType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for SecurityTokenRequestType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for SecurityTokenRequestType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for SecurityTokenRequestType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for SecurityTokenRequestType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ServerState {
    Running = 0i32,
    Failed = 1i32,
    NoConfiguration = 2i32,
    Suspended = 3i32,
    Shutdown = 4i32,
    Test = 5i32,
    CommunicationFault = 6i32,
    Unknown = 7i32,
}
impl TryFrom<i32> for ServerState {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Running,
                1i32 => Self::Failed,
                2i32 => Self::NoConfiguration,
                3i32 => Self::Suspended,
                4i32 => Self::Shutdown,
                5i32 => Self::Test,
                6i32 => Self::CommunicationFault,
                7i32 => Self::Unknown,
                r => {
                    log::error!("Got unexpected value for enum ServerState: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for ServerState {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum ServerState: {}", e)
                })?,
        )
    }
}
impl From<ServerState> for i32 {
    fn from(value: ServerState) -> Self {
        value as i32
    }
}
impl From<ServerState> for opcua::types::Variant {
    fn from(value: ServerState) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for ServerState {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for ServerState {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for ServerState {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for ServerState {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum StructureType {
    Structure = 0i32,
    StructureWithOptionalFields = 1i32,
    Union = 2i32,
}
impl TryFrom<i32> for StructureType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Structure,
                1i32 => Self::StructureWithOptionalFields,
                2i32 => Self::Union,
                r => {
                    log::error!("Got unexpected value for enum StructureType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for StructureType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum StructureType: {}", e)
                })?,
        )
    }
}
impl From<StructureType> for i32 {
    fn from(value: StructureType) -> Self {
        value as i32
    }
}
impl From<StructureType> for opcua::types::Variant {
    fn from(value: StructureType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for StructureType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for StructureType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for StructureType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for StructureType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TimestampsToReturn {
    Source = 0i32,
    Server = 1i32,
    Both = 2i32,
    Neither = 3i32,
    Invalid = 4i32,
}
impl TryFrom<i32> for TimestampsToReturn {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Source,
                1i32 => Self::Server,
                2i32 => Self::Both,
                3i32 => Self::Neither,
                4i32 => Self::Invalid,
                r => {
                    log::warn!(
                        "Got unexpected value for enum TimestampsToReturn: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for TimestampsToReturn {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum TimestampsToReturn: {}", e)
                })?,
        )
    }
}
impl From<TimestampsToReturn> for i32 {
    fn from(value: TimestampsToReturn) -> Self {
        value as i32
    }
}
impl From<TimestampsToReturn> for opcua::types::Variant {
    fn from(value: TimestampsToReturn) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for TimestampsToReturn {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for TimestampsToReturn {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for TimestampsToReturn {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for TimestampsToReturn {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TrustListMasks {
    None = 0i32,
    TrustedCertificates = 1i32,
    TrustedCrls = 2i32,
    IssuerCertificates = 4i32,
    IssuerCrls = 8i32,
    All = 15i32,
}
impl TryFrom<i32> for TrustListMasks {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::TrustedCertificates,
                2i32 => Self::TrustedCrls,
                4i32 => Self::IssuerCertificates,
                8i32 => Self::IssuerCrls,
                15i32 => Self::All,
                r => {
                    log::error!("Got unexpected value for enum TrustListMasks: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for TrustListMasks {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum TrustListMasks: {}", e)
                })?,
        )
    }
}
impl From<TrustListMasks> for i32 {
    fn from(value: TrustListMasks) -> Self {
        value as i32
    }
}
impl From<TrustListMasks> for opcua::types::Variant {
    fn from(value: TrustListMasks) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for TrustListMasks {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for TrustListMasks {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for TrustListMasks {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for TrustListMasks {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpDataSetMessageContentMask :
    i32 { const None = 0i32; const Timestamp = 1i32; const PicoSeconds = 2i32; const
    Status = 4i32; const MajorVersion = 8i32; const MinorVersion = 16i32; const
    SequenceNumber = 32i32; }
}
impl opcua::types::BinaryEncodable for UadpDataSetMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for UadpDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<UadpDataSetMessageContentMask> for opcua::types::Variant {
    fn from(v: UadpDataSetMessageContentMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for UadpDataSetMessageContentMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UadpDataSetMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for UadpDataSetMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(UadpDataSetMessageContentMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for UadpDataSetMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpNetworkMessageContentMask :
    i32 { const None = 0i32; const PublisherId = 1i32; const GroupHeader = 2i32; const
    WriterGroupId = 4i32; const GroupVersion = 8i32; const NetworkMessageNumber = 16i32;
    const SequenceNumber = 32i32; const PayloadHeader = 64i32; const Timestamp = 128i32;
    const PicoSeconds = 256i32; const DataSetClassId = 512i32; const PromotedFields =
    1024i32; }
}
impl opcua::types::BinaryEncodable for UadpNetworkMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for UadpNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl From<UadpNetworkMessageContentMask> for opcua::types::Variant {
    fn from(v: UadpNetworkMessageContentMask) -> Self {
        Self::from(v.bits())
    }
}
impl opcua::types::AsVariantRef for UadpNetworkMessageContentMask {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        self.bits().into()
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UadpNetworkMessageContentMask {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::from_bits_truncate(val))
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for UadpNetworkMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(UadpNetworkMessageContentMask::from_bits_truncate)
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for UadpNetworkMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum UserTokenType {
    Anonymous = 0i32,
    UserName = 1i32,
    Certificate = 2i32,
    IssuedToken = 3i32,
}
impl TryFrom<i32> for UserTokenType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Anonymous,
                1i32 => Self::UserName,
                2i32 => Self::Certificate,
                3i32 => Self::IssuedToken,
                r => {
                    log::error!("Got unexpected value for enum UserTokenType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for UserTokenType {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(
            Self::try_from(val)
                .map_err(|e| {
                    format!("Got unexpected value for enum UserTokenType: {}", e)
                })?,
        )
    }
}
impl From<UserTokenType> for i32 {
    fn from(value: UserTokenType) -> Self {
        value as i32
    }
}
impl From<UserTokenType> for opcua::types::Variant {
    fn from(value: UserTokenType) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for UserTokenType {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for UserTokenType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for UserTokenType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for UserTokenType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
