// This file was autogenerated from tools/schema/schemas/1.0.4/Opc.Ua.Types.bsd by opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Adam Lock, Einar Omang
#[allow(unused)]
mod opcua { pub use crate as types; }bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelExType : i32 { const
    None = 0i32; const CurrentRead = 1i32; const CurrentWrite = 2i32; const HistoryRead =
    4i32; const HistoryWrite = 8i32; const SemanticChange = 16i32; const StatusWrite =
    32i32; const TimestampWrite = 64i32; const NonatomicRead = 256i32; const
    NonatomicWrite = 512i32; const WriteFullArrayOnly = 1024i32; const NoSubDataTypes =
    2048i32; }
}
impl opcua::types::BinaryEncoder for AccessLevelExType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for AccessLevelExType {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for AccessLevelExType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| AccessLevelExType::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for AccessLevelExType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessLevelType : u8 { const None
    = 0u8; const CurrentRead = 1u8; const CurrentWrite = 2u8; const HistoryRead = 4u8;
    const HistoryWrite = 8u8; const SemanticChange = 16u8; const StatusWrite = 32u8;
    const TimestampWrite = 64u8; }
}
impl opcua::types::BinaryEncoder for AccessLevelType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, decoding_options)?))
    }
}
impl Default for AccessLevelType {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for AccessLevelType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = u8;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an u8")
            }
        }
        deserializer
            .deserialize_u8(BitFieldVisitor)
            .map(|v| AccessLevelType::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for AccessLevelType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_u8(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AccessRestrictionType : i16 {
    const None = 0i16; const SigningRequired = 1i16; const EncryptionRequired = 2i16;
    const SessionRequired = 4i16; const ApplyRestrictionsToBrowse = 8i16; }
}
impl opcua::types::BinaryEncoder for AccessRestrictionType {
    fn byte_len(&self) -> usize {
        2usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, decoding_options)?))
    }
}
impl Default for AccessRestrictionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for AccessRestrictionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i16;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i16")
            }
        }
        deserializer
            .deserialize_i16(BitFieldVisitor)
            .map(|v| AccessRestrictionType::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for AccessRestrictionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i16(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ApplicationType {
    Server = 0i32,
    Client = 1i32,
    ClientAndServer = 2i32,
    DiscoveryServer = 3i32,
}
impl TryFrom<i32> for ApplicationType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Server,
                1i32 => Self::Client,
                2i32 => Self::ClientAndServer,
                3i32 => Self::DiscoveryServer,
                r => {
                    log::error!("Got unexpected value for enum ApplicationType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for ApplicationType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct AttributeWriteMask : i32 { const
    None = 0i32; const AccessLevel = 1i32; const ArrayDimensions = 2i32; const BrowseName
    = 4i32; const ContainsNoLoops = 8i32; const DataType = 16i32; const Description =
    32i32; const DisplayName = 64i32; const EventNotifier = 128i32; const Executable =
    256i32; const Historizing = 512i32; const InverseName = 1024i32; const IsAbstract =
    2048i32; const MinimumSamplingInterval = 4096i32; const NodeClass = 8192i32; const
    NodeId = 16384i32; const Symmetric = 32768i32; const UserAccessLevel = 65536i32;
    const UserExecutable = 131072i32; const UserWriteMask = 262144i32; const ValueRank =
    524288i32; const WriteMask = 1048576i32; const ValueForVariableType = 2097152i32;
    const DataTypeDefinition = 4194304i32; const RolePermissions = 8388608i32; const
    AccessRestrictions = 16777216i32; const AccessLevelEx = 33554432i32; }
}
impl opcua::types::BinaryEncoder for AttributeWriteMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for AttributeWriteMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for AttributeWriteMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| AttributeWriteMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for AttributeWriteMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum AxisScaleEnumeration {
    Linear = 0i32,
    Log = 1i32,
    Ln = 2i32,
}
impl TryFrom<i32> for AxisScaleEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Linear,
                1i32 => Self::Log,
                2i32 => Self::Ln,
                r => {
                    log::error!(
                        "Got unexpected value for enum AxisScaleEnumeration: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for AxisScaleEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrokerTransportQualityOfService {
    NotSpecified = 0i32,
    BestEffort = 1i32,
    AtLeastOnce = 2i32,
    AtMostOnce = 3i32,
    ExactlyOnce = 4i32,
}
impl TryFrom<i32> for BrokerTransportQualityOfService {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::NotSpecified,
                1i32 => Self::BestEffort,
                2i32 => Self::AtLeastOnce,
                3i32 => Self::AtMostOnce,
                4i32 => Self::ExactlyOnce,
                r => {
                    log::error!(
                        "Got unexpected value for enum BrokerTransportQualityOfService: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for BrokerTransportQualityOfService {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseDirection {
    Forward = 0i32,
    Inverse = 1i32,
    Both = 2i32,
    Invalid = 3i32,
}
impl TryFrom<i32> for BrowseDirection {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Forward,
                1i32 => Self::Inverse,
                2i32 => Self::Both,
                3i32 => Self::Invalid,
                r => {
                    log::warn!(
                        "Got unexpected value for enum BrowseDirection: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for BrowseDirection {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum BrowseResultMask {
    None = 0i32,
    ReferenceTypeId = 1i32,
    IsForward = 2i32,
    NodeClass = 4i32,
    BrowseName = 8i32,
    DisplayName = 16i32,
    TypeDefinition = 32i32,
    All = 63i32,
    ReferenceTypeInfo = 3i32,
    TargetInfo = 60i32,
}
impl TryFrom<i32> for BrowseResultMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::ReferenceTypeId,
                2i32 => Self::IsForward,
                4i32 => Self::NodeClass,
                8i32 => Self::BrowseName,
                16i32 => Self::DisplayName,
                32i32 => Self::TypeDefinition,
                63i32 => Self::All,
                3i32 => Self::ReferenceTypeInfo,
                60i32 => Self::TargetInfo,
                r => {
                    log::error!("Got unexpected value for enum BrowseResultMask: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for BrowseResultMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "PascalCase")]
#[repr(i32)]
pub enum DataChangeTrigger {
    Status = 0i32,
    StatusValue = 1i32,
    StatusValueTimestamp = 2i32,
}
impl TryFrom<i32> for DataChangeTrigger {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Status,
                1i32 => Self::StatusValue,
                2i32 => Self::StatusValueTimestamp,
                r => {
                    log::error!(
                        "Got unexpected value for enum DataChangeTrigger: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for DataChangeTrigger {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldContentMask : i32 {
    const None = 0i32; const StatusCode = 1i32; const SourceTimestamp = 2i32; const
    ServerTimestamp = 4i32; const SourcePicoSeconds = 8i32; const ServerPicoSeconds =
    16i32; const RawData = 32i32; }
}
impl opcua::types::BinaryEncoder for DataSetFieldContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for DataSetFieldContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for DataSetFieldContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| DataSetFieldContentMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for DataSetFieldContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct DataSetFieldFlags : i16 { const
    None = 0i16; const PromotedField = 1i16; }
}
impl opcua::types::BinaryEncoder for DataSetFieldFlags {
    fn byte_len(&self) -> usize {
        2usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i16(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i16::decode(stream, decoding_options)?))
    }
}
impl Default for DataSetFieldFlags {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for DataSetFieldFlags {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i16;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i16")
            }
        }
        deserializer
            .deserialize_i16(BitFieldVisitor)
            .map(|v| DataSetFieldFlags::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for DataSetFieldFlags {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i16(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DataSetOrderingType {
    Undefined = 0i32,
    AscendingWriterId = 1i32,
    AscendingWriterIdSingle = 2i32,
}
impl TryFrom<i32> for DataSetOrderingType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Undefined,
                1i32 => Self::AscendingWriterId,
                2i32 => Self::AscendingWriterIdSingle,
                r => {
                    log::error!(
                        "Got unexpected value for enum DataSetOrderingType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for DataSetOrderingType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DeadbandType {
    None = 0i32,
    Absolute = 1i32,
    Percent = 2i32,
}
impl TryFrom<i32> for DeadbandType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::Absolute,
                2i32 => Self::Percent,
                r => {
                    log::error!("Got unexpected value for enum DeadbandType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for DeadbandType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum DiagnosticsLevel {
    Basic = 0i32,
    Advanced = 1i32,
    Info = 2i32,
    Log = 3i32,
    Debug = 4i32,
}
impl TryFrom<i32> for DiagnosticsLevel {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Basic,
                1i32 => Self::Advanced,
                2i32 => Self::Info,
                3i32 => Self::Log,
                4i32 => Self::Debug,
                r => {
                    log::error!("Got unexpected value for enum DiagnosticsLevel: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for DiagnosticsLevel {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct EventNotifierType : u8 { const
    None = 0u8; const SubscribeToEvents = 1u8; const HistoryRead = 4u8; const
    HistoryWrite = 8u8; }
}
impl opcua::types::BinaryEncoder for EventNotifierType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(u8::decode(stream, decoding_options)?))
    }
}
impl Default for EventNotifierType {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for EventNotifierType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = u8;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an u8")
            }
        }
        deserializer
            .deserialize_u8(BitFieldVisitor)
            .map(|v| EventNotifierType::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for EventNotifierType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_u8(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ExceptionDeviationFormat {
    AbsoluteValue = 0i32,
    PercentOfValue = 1i32,
    PercentOfRange = 2i32,
    PercentOfEURange = 3i32,
    Unknown = 4i32,
}
impl TryFrom<i32> for ExceptionDeviationFormat {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::AbsoluteValue,
                1i32 => Self::PercentOfValue,
                2i32 => Self::PercentOfRange,
                3i32 => Self::PercentOfEURange,
                4i32 => Self::Unknown,
                r => {
                    log::error!(
                        "Got unexpected value for enum ExceptionDeviationFormat: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for ExceptionDeviationFormat {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "PascalCase")]
#[repr(i32)]
pub enum FilterOperator {
    Equals = 0i32,
    IsNull = 1i32,
    GreaterThan = 2i32,
    LessThan = 3i32,
    GreaterThanOrEqual = 4i32,
    LessThanOrEqual = 5i32,
    Like = 6i32,
    Not = 7i32,
    Between = 8i32,
    InList = 9i32,
    And = 10i32,
    Or = 11i32,
    Cast = 12i32,
    InView = 13i32,
    OfType = 14i32,
    RelatedTo = 15i32,
    BitwiseAnd = 16i32,
    BitwiseOr = 17i32,
}
impl TryFrom<i32> for FilterOperator {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Equals,
                1i32 => Self::IsNull,
                2i32 => Self::GreaterThan,
                3i32 => Self::LessThan,
                4i32 => Self::GreaterThanOrEqual,
                5i32 => Self::LessThanOrEqual,
                6i32 => Self::Like,
                7i32 => Self::Not,
                8i32 => Self::Between,
                9i32 => Self::InList,
                10i32 => Self::And,
                11i32 => Self::Or,
                12i32 => Self::Cast,
                13i32 => Self::InView,
                14i32 => Self::OfType,
                15i32 => Self::RelatedTo,
                16i32 => Self::BitwiseAnd,
                17i32 => Self::BitwiseOr,
                r => {
                    log::error!("Got unexpected value for enum FilterOperator: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for FilterOperator {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum HistoryUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Delete = 4i32,
}
impl TryFrom<i32> for HistoryUpdateType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Insert,
                2i32 => Self::Replace,
                3i32 => Self::Update,
                4i32 => Self::Delete,
                r => {
                    log::error!(
                        "Got unexpected value for enum HistoryUpdateType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for HistoryUpdateType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdentityCriteriaType {
    UserName = 1i32,
    Thumbprint = 2i32,
    Role = 3i32,
    GroupId = 4i32,
    Anonymous = 5i32,
    AuthenticatedUser = 6i32,
}
impl TryFrom<i32> for IdentityCriteriaType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::UserName,
                2i32 => Self::Thumbprint,
                3i32 => Self::Role,
                4i32 => Self::GroupId,
                5i32 => Self::Anonymous,
                6i32 => Self::AuthenticatedUser,
                r => {
                    log::error!(
                        "Got unexpected value for enum IdentityCriteriaType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for IdentityCriteriaType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IdType {
    Numeric = 0i32,
    String = 1i32,
    Guid = 2i32,
    Opaque = 3i32,
}
impl TryFrom<i32> for IdType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Numeric,
                1i32 => Self::String,
                2i32 => Self::Guid,
                3i32 => Self::Opaque,
                r => {
                    log::error!("Got unexpected value for enum IdType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for IdType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonDataSetMessageContentMask :
    i32 { const None = 0i32; const DataSetWriterId = 1i32; const MetaDataVersion = 2i32;
    const SequenceNumber = 4i32; const Timestamp = 8i32; const Status = 16i32; }
}
impl opcua::types::BinaryEncoder for JsonDataSetMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for JsonDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for JsonDataSetMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| JsonDataSetMessageContentMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for JsonDataSetMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct JsonNetworkMessageContentMask :
    i32 { const None = 0i32; const NetworkMessageHeader = 1i32; const
    DataSetMessageHeader = 2i32; const SingleDataSetMessage = 4i32; const PublisherId =
    8i32; const DataSetClassId = 16i32; const ReplyTo = 32i32; }
}
impl opcua::types::BinaryEncoder for JsonNetworkMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for JsonNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for JsonNetworkMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| JsonNetworkMessageContentMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for JsonNetworkMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum MessageSecurityMode {
    Invalid = 0i32,
    None = 1i32,
    Sign = 2i32,
    SignAndEncrypt = 3i32,
}
impl TryFrom<i32> for MessageSecurityMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Invalid,
                1i32 => Self::None,
                2i32 => Self::Sign,
                3i32 => Self::SignAndEncrypt,
                r => {
                    log::warn!(
                        "Got unexpected value for enum MessageSecurityMode: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for MessageSecurityMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ModelChangeStructureVerbMask {
    NodeAdded = 1i32,
    NodeDeleted = 2i32,
    ReferenceAdded = 4i32,
    ReferenceDeleted = 8i32,
    DataTypeChanged = 16i32,
}
impl TryFrom<i32> for ModelChangeStructureVerbMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::NodeAdded,
                2i32 => Self::NodeDeleted,
                4i32 => Self::ReferenceAdded,
                8i32 => Self::ReferenceDeleted,
                16i32 => Self::DataTypeChanged,
                r => {
                    log::error!(
                        "Got unexpected value for enum ModelChangeStructureVerbMask: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for ModelChangeStructureVerbMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "PascalCase")]
#[repr(i32)]
pub enum MonitoringMode {
    Disabled = 0i32,
    Sampling = 1i32,
    Reporting = 2i32,
}
impl TryFrom<i32> for MonitoringMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::Sampling,
                2i32 => Self::Reporting,
                r => {
                    log::error!("Got unexpected value for enum MonitoringMode: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for MonitoringMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NamingRuleType {
    Mandatory = 1i32,
    Optional = 2i32,
    Constraint = 3i32,
}
impl TryFrom<i32> for NamingRuleType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Mandatory,
                2i32 => Self::Optional,
                3i32 => Self::Constraint,
                r => {
                    log::error!("Got unexpected value for enum NamingRuleType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for NamingRuleType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeAttributesMask {
    None = 0i32,
    AccessLevel = 1i32,
    ArrayDimensions = 2i32,
    BrowseName = 4i32,
    ContainsNoLoops = 8i32,
    DataType = 16i32,
    Description = 32i32,
    DisplayName = 64i32,
    EventNotifier = 128i32,
    Executable = 256i32,
    Historizing = 512i32,
    InverseName = 1024i32,
    IsAbstract = 2048i32,
    MinimumSamplingInterval = 4096i32,
    NodeClass = 8192i32,
    NodeId = 16384i32,
    Symmetric = 32768i32,
    UserAccessLevel = 65536i32,
    UserExecutable = 131072i32,
    UserWriteMask = 262144i32,
    ValueRank = 524288i32,
    WriteMask = 1048576i32,
    Value = 2097152i32,
    DataTypeDefinition = 4194304i32,
    RolePermissions = 8388608i32,
    AccessRestrictions = 16777216i32,
    All = 33554431i32,
    BaseNode = 26501220i32,
    Object = 26501348i32,
    ObjectType = 26503268i32,
    Variable = 26571383i32,
    VariableType = 28600438i32,
    Method = 26632548i32,
    ReferenceType = 26537060i32,
    View = 26501356i32,
}
impl TryFrom<i32> for NodeAttributesMask {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::AccessLevel,
                2i32 => Self::ArrayDimensions,
                4i32 => Self::BrowseName,
                8i32 => Self::ContainsNoLoops,
                16i32 => Self::DataType,
                32i32 => Self::Description,
                64i32 => Self::DisplayName,
                128i32 => Self::EventNotifier,
                256i32 => Self::Executable,
                512i32 => Self::Historizing,
                1024i32 => Self::InverseName,
                2048i32 => Self::IsAbstract,
                4096i32 => Self::MinimumSamplingInterval,
                8192i32 => Self::NodeClass,
                16384i32 => Self::NodeId,
                32768i32 => Self::Symmetric,
                65536i32 => Self::UserAccessLevel,
                131072i32 => Self::UserExecutable,
                262144i32 => Self::UserWriteMask,
                524288i32 => Self::ValueRank,
                1048576i32 => Self::WriteMask,
                2097152i32 => Self::Value,
                4194304i32 => Self::DataTypeDefinition,
                8388608i32 => Self::RolePermissions,
                16777216i32 => Self::AccessRestrictions,
                33554431i32 => Self::All,
                26501220i32 => Self::BaseNode,
                26501348i32 => Self::Object,
                26503268i32 => Self::ObjectType,
                26571383i32 => Self::Variable,
                28600438i32 => Self::VariableType,
                26632548i32 => Self::Method,
                26537060i32 => Self::ReferenceType,
                26501356i32 => Self::View,
                r => {
                    log::error!(
                        "Got unexpected value for enum NodeAttributesMask: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for NodeAttributesMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum NodeClass {
    Unspecified = 0i32,
    Object = 1i32,
    Variable = 2i32,
    Method = 4i32,
    ObjectType = 8i32,
    VariableType = 16i32,
    ReferenceType = 32i32,
    DataType = 64i32,
    View = 128i32,
}
impl TryFrom<i32> for NodeClass {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Unspecified,
                1i32 => Self::Object,
                2i32 => Self::Variable,
                4i32 => Self::Method,
                8i32 => Self::ObjectType,
                16i32 => Self::VariableType,
                32i32 => Self::ReferenceType,
                64i32 => Self::DataType,
                128i32 => Self::View,
                r => {
                    log::error!("Got unexpected value for enum NodeClass: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for NodeClass {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
///The possible encodings for a NodeId value.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NodeIdType {
    TwoByte = 0u8,
    FourByte = 1u8,
    Numeric = 2u8,
    String = 3u8,
    Guid = 4u8,
    ByteString = 5u8,
}
impl TryFrom<u8> for NodeIdType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: u8) -> Result<Self, <Self as TryFrom<u8>>::Error> {
        Ok(
            match value {
                0u8 => Self::TwoByte,
                1u8 => Self::FourByte,
                2u8 => Self::Numeric,
                3u8 => Self::String,
                4u8 => Self::Guid,
                5u8 => Self::ByteString,
                r => {
                    log::error!("Got unexpected value for enum NodeIdType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for NodeIdType {
    fn byte_len(&self) -> usize {
        1usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_u8(stream, *self as u8)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_u8(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OpenFileMode {
    Read = 1i32,
    Write = 2i32,
    EraseExisting = 4i32,
    Append = 8i32,
}
impl TryFrom<i32> for OpenFileMode {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Read,
                2i32 => Self::Write,
                4i32 => Self::EraseExisting,
                8i32 => Self::Append,
                r => {
                    log::error!("Got unexpected value for enum OpenFileMode: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for OpenFileMode {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum OverrideValueHandling {
    Disabled = 0i32,
    LastUsableValue = 1i32,
    OverrideValue = 2i32,
}
impl TryFrom<i32> for OverrideValueHandling {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::LastUsableValue,
                2i32 => Self::OverrideValue,
                r => {
                    log::error!(
                        "Got unexpected value for enum OverrideValueHandling: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for OverrideValueHandling {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PerformUpdateType {
    Insert = 1i32,
    Replace = 2i32,
    Update = 3i32,
    Remove = 4i32,
}
impl TryFrom<i32> for PerformUpdateType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                1i32 => Self::Insert,
                2i32 => Self::Replace,
                3i32 => Self::Update,
                4i32 => Self::Remove,
                r => {
                    log::error!(
                        "Got unexpected value for enum PerformUpdateType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for PerformUpdateType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct PermissionType : i32 { const None
    = 0i32; const Browse = 1i32; const ReadRolePermissions = 2i32; const WriteAttribute =
    4i32; const WriteRolePermissions = 8i32; const WriteHistorizing = 16i32; const Read =
    32i32; const Write = 64i32; const ReadHistory = 128i32; const InsertHistory = 256i32;
    const ModifyHistory = 512i32; const DeleteHistory = 1024i32; const ReceiveEvents =
    2048i32; const Call = 4096i32; const AddReference = 8192i32; const RemoveReference =
    16384i32; const DeleteNode = 32768i32; const AddNode = 65536i32; }
}
impl opcua::types::BinaryEncoder for PermissionType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for PermissionType {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for PermissionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| PermissionType::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for PermissionType {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubDiagnosticsCounterClassification {
    Information = 0i32,
    Error = 1i32,
}
impl TryFrom<i32> for PubSubDiagnosticsCounterClassification {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Information,
                1i32 => Self::Error,
                r => {
                    log::error!(
                        "Got unexpected value for enum PubSubDiagnosticsCounterClassification: {}",
                        r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for PubSubDiagnosticsCounterClassification {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PubSubState {
    Disabled = 0i32,
    Paused = 1i32,
    Operational = 2i32,
    Error = 3i32,
}
impl TryFrom<i32> for PubSubState {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Disabled,
                1i32 => Self::Paused,
                2i32 => Self::Operational,
                3i32 => Self::Error,
                r => {
                    log::error!("Got unexpected value for enum PubSubState: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for PubSubState {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum RedundancySupport {
    None = 0i32,
    Cold = 1i32,
    Warm = 2i32,
    Hot = 3i32,
    Transparent = 4i32,
    HotAndMirrored = 5i32,
}
impl TryFrom<i32> for RedundancySupport {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::Cold,
                2i32 => Self::Warm,
                3i32 => Self::Hot,
                4i32 => Self::Transparent,
                5i32 => Self::HotAndMirrored,
                r => {
                    log::error!(
                        "Got unexpected value for enum RedundancySupport: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for RedundancySupport {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum SecurityTokenRequestType {
    Issue = 0i32,
    Renew = 1i32,
}
impl TryFrom<i32> for SecurityTokenRequestType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Issue,
                1i32 => Self::Renew,
                r => {
                    log::error!(
                        "Got unexpected value for enum SecurityTokenRequestType: {}", r
                    );
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for SecurityTokenRequestType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum ServerState {
    Running = 0i32,
    Failed = 1i32,
    NoConfiguration = 2i32,
    Suspended = 3i32,
    Shutdown = 4i32,
    Test = 5i32,
    CommunicationFault = 6i32,
    Unknown = 7i32,
}
impl TryFrom<i32> for ServerState {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Running,
                1i32 => Self::Failed,
                2i32 => Self::NoConfiguration,
                3i32 => Self::Suspended,
                4i32 => Self::Shutdown,
                5i32 => Self::Test,
                6i32 => Self::CommunicationFault,
                7i32 => Self::Unknown,
                r => {
                    log::error!("Got unexpected value for enum ServerState: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for ServerState {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "PascalCase")]
#[repr(i32)]
pub enum StructureType {
    Structure = 0i32,
    StructureWithOptionalFields = 1i32,
    Union = 2i32,
}
impl TryFrom<i32> for StructureType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Structure,
                1i32 => Self::StructureWithOptionalFields,
                2i32 => Self::Union,
                r => {
                    log::error!("Got unexpected value for enum StructureType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for StructureType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "PascalCase")]
#[repr(i32)]
pub enum TimestampsToReturn {
    Source = 0i32,
    Server = 1i32,
    Both = 2i32,
    Neither = 3i32,
    Invalid = 4i32,
}
impl TryFrom<i32> for TimestampsToReturn {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Source,
                1i32 => Self::Server,
                2i32 => Self::Both,
                3i32 => Self::Neither,
                4i32 => Self::Invalid,
                r => {
                    log::warn!(
                        "Got unexpected value for enum TimestampsToReturn: {}. Falling back on Invalid",
                        r
                    );
                    Self::Invalid
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for TimestampsToReturn {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum TrustListMasks {
    None = 0i32,
    TrustedCertificates = 1i32,
    TrustedCrls = 2i32,
    IssuerCertificates = 4i32,
    IssuerCrls = 8i32,
    All = 15i32,
}
impl TryFrom<i32> for TrustListMasks {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::None,
                1i32 => Self::TrustedCertificates,
                2i32 => Self::TrustedCrls,
                4i32 => Self::IssuerCertificates,
                8i32 => Self::IssuerCrls,
                15i32 => Self::All,
                r => {
                    log::error!("Got unexpected value for enum TrustListMasks: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for TrustListMasks {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpDataSetMessageContentMask :
    i32 { const None = 0i32; const Timestamp = 1i32; const PicoSeconds = 2i32; const
    Status = 4i32; const MajorVersion = 8i32; const MinorVersion = 16i32; const
    SequenceNumber = 32i32; }
}
impl opcua::types::BinaryEncoder for UadpDataSetMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for UadpDataSetMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for UadpDataSetMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| UadpDataSetMessageContentMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for UadpDataSetMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
bitflags::bitflags! {
    #[derive(Debug, Copy, Clone, PartialEq)] pub struct UadpNetworkMessageContentMask :
    i32 { const None = 0i32; const PublisherId = 1i32; const GroupHeader = 2i32; const
    WriterGroupId = 4i32; const GroupVersion = 8i32; const NetworkMessageNumber = 16i32;
    const SequenceNumber = 32i32; const PayloadHeader = 64i32; const Timestamp = 128i32;
    const PicoSeconds = 256i32; const DataSetClassId = 512i32; const PromotedFields =
    1024i32; }
}
impl opcua::types::BinaryEncoder for UadpNetworkMessageContentMask {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, self.bits())
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        Ok(Self::from_bits_truncate(i32::decode(stream, decoding_options)?))
    }
}
impl Default for UadpNetworkMessageContentMask {
    fn default() -> Self {
        Self::empty()
    }
}
impl<'de> serde::de::Deserialize<'de> for UadpNetworkMessageContentMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct BitFieldVisitor;
        impl<'de> serde::de::Visitor<'de> for BitFieldVisitor {
            type Value = i32;
            fn expecting(
                &self,
                formatter: &mut core::fmt::Formatter,
            ) -> core::fmt::Result {
                write!(formatter, "an i32")
            }
        }
        deserializer
            .deserialize_i32(BitFieldVisitor)
            .map(|v| UadpNetworkMessageContentMask::from_bits_truncate(v))
    }
}
impl serde::ser::Serialize for UadpNetworkMessageContentMask {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(self.bits())
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum UserTokenType {
    Anonymous = 0i32,
    UserName = 1i32,
    Certificate = 2i32,
    IssuedToken = 3i32,
}
impl TryFrom<i32> for UserTokenType {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(
            match value {
                0i32 => Self::Anonymous,
                1i32 => Self::UserName,
                2i32 => Self::Certificate,
                3i32 => Self::IssuedToken,
                r => {
                    log::error!("Got unexpected value for enum UserTokenType: {}", r);
                    return Err(opcua::types::StatusCode::BadUnexpectedError);
                }
            },
        )
    }
}
impl opcua::types::BinaryEncoder for UserTokenType {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
