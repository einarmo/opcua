// This file was autogenerated from schema/Opc.Ua.Pn.Types.bsd by opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Einar Omang
#![allow(non_camel_case_types)]
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "json", serde_with::skip_serializing_none)]
#[cfg_attr(feature = "json", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "json", serde(rename_all = "PascalCase"))]
#[cfg_attr(feature = "xml", derive(opcua::types::FromXml))]
pub struct PnDeviceDiagnosisDataType {
    pub api: u32,
    pub slot: u16,
    pub subslot: u16,
    pub channel_number: u16,
    pub __type: super::enums::PnChannelTypeEnumeration,
    pub accumulative: super::enums::PnChannelAccumulativeEnumeration,
    pub maintenance: super::enums::PnChannelMaintenanceEnumeration,
    pub specifier: super::enums::PnChannelSpecifierEnumeration,
    pub direction: super::enums::PnChannelDirectionEnumeration,
    pub user_structure_identifier: u16,
    pub channel_error_type: u16,
    pub ext_channel_error_type: u16,
    pub ext_channel_add_value: u32,
    pub qualified_channel_qualifier: u32,
    pub manufacturer_data: opcua::types::byte_string::ByteString,
    pub message: opcua::types::localized_text::LocalizedText,
    pub help_text: opcua::types::localized_text::LocalizedText,
}
impl opcua::types::ExpandedMessageInfo for PnDeviceDiagnosisDataType {
    fn full_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId =
            crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultBinary.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
    fn full_json_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId =
            crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultJson.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
    fn full_xml_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId =
            crate::ObjectId::PnDeviceDiagnosisDataType_Encoding_DefaultXml.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
}
impl opcua::types::BinaryEncodable for PnDeviceDiagnosisDataType {
    fn byte_len(&self) -> usize {
        let mut size = 0usize;
        size += self.api.byte_len();
        size += self.slot.byte_len();
        size += self.subslot.byte_len();
        size += self.channel_number.byte_len();
        size += self.__type.byte_len();
        size += self.accumulative.byte_len();
        size += self.maintenance.byte_len();
        size += self.specifier.byte_len();
        size += self.direction.byte_len();
        size += self.user_structure_identifier.byte_len();
        size += self.channel_error_type.byte_len();
        size += self.ext_channel_error_type.byte_len();
        size += self.ext_channel_add_value.byte_len();
        size += self.qualified_channel_qualifier.byte_len();
        size += self.manufacturer_data.byte_len();
        size += self.message.byte_len();
        size += self.help_text.byte_len();
        size
    }
    #[allow(unused_variables)]
    fn encode<S: std::io::Write>(&self, stream: &mut S) -> opcua::types::EncodingResult<usize> {
        let mut size = 0usize;
        size += self.api.encode(stream)?;
        size += self.slot.encode(stream)?;
        size += self.subslot.encode(stream)?;
        size += self.channel_number.encode(stream)?;
        size += self.__type.encode(stream)?;
        size += self.accumulative.encode(stream)?;
        size += self.maintenance.encode(stream)?;
        size += self.specifier.encode(stream)?;
        size += self.direction.encode(stream)?;
        size += self.user_structure_identifier.encode(stream)?;
        size += self.channel_error_type.encode(stream)?;
        size += self.ext_channel_error_type.encode(stream)?;
        size += self.ext_channel_add_value.encode(stream)?;
        size += self.qualified_channel_qualifier.encode(stream)?;
        size += self.manufacturer_data.encode(stream)?;
        size += self.message.encode(stream)?;
        size += self.help_text.encode(stream)?;
        Ok(size)
    }
    #[allow(unused_variables)]
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let api = <u32 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let slot = <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let subslot = <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let channel_number =
            <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let __type =
            <super::enums::PnChannelTypeEnumeration as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let accumulative = <super::enums::PnChannelAccumulativeEnumeration as opcua::types::BinaryEncodable>::decode(
            stream,
            decoding_options,
        )?;
        let maintenance = <super::enums::PnChannelMaintenanceEnumeration as opcua::types::BinaryEncodable>::decode(
            stream,
            decoding_options,
        )?;
        let specifier =
            <super::enums::PnChannelSpecifierEnumeration as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let direction =
            <super::enums::PnChannelDirectionEnumeration as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let user_structure_identifier =
            <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let channel_error_type =
            <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let ext_channel_error_type =
            <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let ext_channel_add_value =
            <u32 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let qualified_channel_qualifier =
            <u32 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let manufacturer_data =
            <opcua::types::byte_string::ByteString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let message =
            <opcua::types::localized_text::LocalizedText as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let help_text =
            <opcua::types::localized_text::LocalizedText as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        Ok(Self {
            api,
            slot,
            subslot,
            channel_number,
            __type,
            accumulative,
            maintenance,
            specifier,
            direction,
            user_structure_identifier,
            channel_error_type,
            ext_channel_error_type,
            ext_channel_add_value,
            qualified_channel_qualifier,
            manufacturer_data,
            message,
            help_text,
        })
    }
}
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "json", serde_with::skip_serializing_none)]
#[cfg_attr(feature = "json", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "json", serde(rename_all = "PascalCase"))]
#[cfg_attr(feature = "xml", derive(opcua::types::FromXml))]
#[derive(Default)]
pub struct PnDeviceRoleOptionSet {
    pub value: opcua::types::byte_string::ByteString,
    pub valid_bits: opcua::types::byte_string::ByteString,
}
impl opcua::types::BinaryEncodable for PnDeviceRoleOptionSet {
    fn byte_len(&self) -> usize {
        let mut size = 0usize;
        size += self.value.byte_len();
        size += self.valid_bits.byte_len();
        size
    }
    #[allow(unused_variables)]
    fn encode<S: std::io::Write>(&self, stream: &mut S) -> opcua::types::EncodingResult<usize> {
        let mut size = 0usize;
        size += self.value.encode(stream)?;
        size += self.valid_bits.encode(stream)?;
        Ok(size)
    }
    #[allow(unused_variables)]
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value =
            <opcua::types::byte_string::ByteString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let valid_bits =
            <opcua::types::byte_string::ByteString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        Ok(Self { value, valid_bits })
    }
}
///Contains the fields of the APDU element I&M5 | I&M5Data
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "json", serde_with::skip_serializing_none)]
#[cfg_attr(feature = "json", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "json", serde(rename_all = "PascalCase"))]
#[cfg_attr(feature = "xml", derive(opcua::types::FromXml))]
#[derive(Default)]
pub struct PnIM5DataType {
    pub annotation: opcua::types::string::UAString,
    pub order_id: opcua::types::string::UAString,
    pub vendor_id: u16,
    pub serial_number: opcua::types::string::UAString,
    pub hardware_revision: opcua::types::string::UAString,
    pub software_revision: opcua::types::string::UAString,
}
impl opcua::types::ExpandedMessageInfo for PnIM5DataType {
    fn full_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId = crate::ObjectId::PnIM5DataType_Encoding_DefaultBinary.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
    fn full_json_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId = crate::ObjectId::PnIM5DataType_Encoding_DefaultJson.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
    fn full_xml_type_id(&self) -> opcua::types::ExpandedNodeId {
        let id: opcua::types::NodeId = crate::ObjectId::PnIM5DataType_Encoding_DefaultXml.into();
        opcua::types::ExpandedNodeId::from((id, "http://opcfoundation.org/UA/PROFINET/"))
    }
}
impl opcua::types::BinaryEncodable for PnIM5DataType {
    fn byte_len(&self) -> usize {
        let mut size = 0usize;
        size += self.annotation.byte_len();
        size += self.order_id.byte_len();
        size += self.vendor_id.byte_len();
        size += self.serial_number.byte_len();
        size += self.hardware_revision.byte_len();
        size += self.software_revision.byte_len();
        size
    }
    #[allow(unused_variables)]
    fn encode<S: std::io::Write>(&self, stream: &mut S) -> opcua::types::EncodingResult<usize> {
        let mut size = 0usize;
        size += self.annotation.encode(stream)?;
        size += self.order_id.encode(stream)?;
        size += self.vendor_id.encode(stream)?;
        size += self.serial_number.encode(stream)?;
        size += self.hardware_revision.encode(stream)?;
        size += self.software_revision.encode(stream)?;
        Ok(size)
    }
    #[allow(unused_variables)]
    fn decode<S: std::io::Read>(
        stream: &mut S,
        decoding_options: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let annotation = <opcua::types::string::UAString as opcua::types::BinaryEncodable>::decode(
            stream,
            decoding_options,
        )?;
        let order_id = <opcua::types::string::UAString as opcua::types::BinaryEncodable>::decode(
            stream,
            decoding_options,
        )?;
        let vendor_id = <u16 as opcua::types::BinaryEncodable>::decode(stream, decoding_options)?;
        let serial_number =
            <opcua::types::string::UAString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let hardware_revision =
            <opcua::types::string::UAString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        let software_revision =
            <opcua::types::string::UAString as opcua::types::BinaryEncodable>::decode(
                stream,
                decoding_options,
            )?;
        Ok(Self {
            annotation,
            order_id,
            vendor_id,
            serial_number,
            hardware_revision,
            software_revision,
        })
    }
}
