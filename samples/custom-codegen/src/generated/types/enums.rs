// This file was autogenerated from schema/Opc.Ua.Pn.Types.bsd by opcua-codegen
//
// DO NOT EDIT THIS FILE

// OPCUA for Rust
// SPDX-License-Identifier: MPL-2.0
// Copyright (C) 2017-2024 Einar Omang
#![allow(non_camel_case_types)]
#![allow(clippy::upper_case_acronyms)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum IMTagSelectorEnumeration {
    FUNCTION = 0i32,
    LOCATION = 1i32,
    BOTH = 2i32,
}
impl TryFrom<i32> for IMTagSelectorEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::FUNCTION,
            1i32 => Self::LOCATION,
            2i32 => Self::BOTH,
            r => {
                log::error!(
                    "Got unexpected value for enum IMTagSelectorEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for IMTagSelectorEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum IMTagSelectorEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<IMTagSelectorEnumeration> for i32 {
    fn from(value: IMTagSelectorEnumeration) -> Self {
        value as i32
    }
}
impl From<IMTagSelectorEnumeration> for opcua::types::Variant {
    fn from(value: IMTagSelectorEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for IMTagSelectorEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for IMTagSelectorEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for IMTagSelectorEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for IMTagSelectorEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for IMTagSelectorEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnARStateEnumeration {
    CONNECTED = 0i32,
    UNCONNECTED = 1i32,
    UNCONNECTED_ERR_DEVICE_NOT_FOUND = 2i32,
    UNCONNECTED_ERR_DUPLICATE_IP = 3i32,
    UNCONNECTED_ERR_DUPLICATE_NOS = 4i32,
}
impl TryFrom<i32> for PnARStateEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::CONNECTED,
            1i32 => Self::UNCONNECTED,
            2i32 => Self::UNCONNECTED_ERR_DEVICE_NOT_FOUND,
            3i32 => Self::UNCONNECTED_ERR_DUPLICATE_IP,
            4i32 => Self::UNCONNECTED_ERR_DUPLICATE_NOS,
            r => {
                log::error!("Got unexpected value for enum PnARStateEnumeration: {}", r);
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnARStateEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum PnARStateEnumeration: {}", e))?)
    }
}
impl From<PnARStateEnumeration> for i32 {
    fn from(value: PnARStateEnumeration) -> Self {
        value as i32
    }
}
impl From<PnARStateEnumeration> for opcua::types::Variant {
    fn from(value: PnARStateEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnARStateEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnARStateEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnARStateEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnARStateEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnARStateEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnARTypeEnumeration {
    IOCARSingle = 0i32,
    IOSAR = 6i32,
    IOCARSingleUsingRT_CLASS_3 = 16i32,
    IOCARSR = 32i32,
}
impl TryFrom<i32> for PnARTypeEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::IOCARSingle,
            6i32 => Self::IOSAR,
            16i32 => Self::IOCARSingleUsingRT_CLASS_3,
            32i32 => Self::IOCARSR,
            r => {
                log::error!("Got unexpected value for enum PnARTypeEnumeration: {}", r);
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnARTypeEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val)
            .map_err(|e| format!("Got unexpected value for enum PnARTypeEnumeration: {}", e))?)
    }
}
impl From<PnARTypeEnumeration> for i32 {
    fn from(value: PnARTypeEnumeration) -> Self {
        value as i32
    }
}
impl From<PnARTypeEnumeration> for opcua::types::Variant {
    fn from(value: PnARTypeEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnARTypeEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnARTypeEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnARTypeEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnARTypeEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnARTypeEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnAssetChangeEnumeration {
    INSERTED = 0i32,
    REMOVED = 1i32,
    CHANGED = 2i32,
}
impl TryFrom<i32> for PnAssetChangeEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::INSERTED,
            1i32 => Self::REMOVED,
            2i32 => Self::CHANGED,
            r => {
                log::error!(
                    "Got unexpected value for enum PnAssetChangeEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnAssetChangeEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnAssetChangeEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnAssetChangeEnumeration> for i32 {
    fn from(value: PnAssetChangeEnumeration) -> Self {
        value as i32
    }
}
impl From<PnAssetChangeEnumeration> for opcua::types::Variant {
    fn from(value: PnAssetChangeEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnAssetChangeEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnAssetChangeEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnAssetChangeEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnAssetChangeEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnAssetChangeEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnAssetTypeEnumeration {
    DEVICE = 0i32,
    MODULE = 1i32,
    SUBMODULE = 2i32,
    ASSET = 3i32,
}
impl TryFrom<i32> for PnAssetTypeEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::DEVICE,
            1i32 => Self::MODULE,
            2i32 => Self::SUBMODULE,
            3i32 => Self::ASSET,
            r => {
                log::error!(
                    "Got unexpected value for enum PnAssetTypeEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnAssetTypeEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnAssetTypeEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnAssetTypeEnumeration> for i32 {
    fn from(value: PnAssetTypeEnumeration) -> Self {
        value as i32
    }
}
impl From<PnAssetTypeEnumeration> for opcua::types::Variant {
    fn from(value: PnAssetTypeEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnAssetTypeEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnAssetTypeEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnAssetTypeEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnAssetTypeEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnAssetTypeEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnChannelAccumulativeEnumeration {
    SINGLE = 0i32,
    ACCUMULATIVE = 256i32,
}
impl TryFrom<i32> for PnChannelAccumulativeEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::SINGLE,
            256i32 => Self::ACCUMULATIVE,
            r => {
                log::error!(
                    "Got unexpected value for enum PnChannelAccumulativeEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnChannelAccumulativeEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnChannelAccumulativeEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnChannelAccumulativeEnumeration> for i32 {
    fn from(value: PnChannelAccumulativeEnumeration) -> Self {
        value as i32
    }
}
impl From<PnChannelAccumulativeEnumeration> for opcua::types::Variant {
    fn from(value: PnChannelAccumulativeEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnChannelAccumulativeEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnChannelAccumulativeEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnChannelAccumulativeEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnChannelAccumulativeEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnChannelAccumulativeEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnChannelDirectionEnumeration {
    MANUFACTURER_SPECIFIC = 0i32,
    INPUT_CHANNEL = 8192i32,
    OUTPUT_CHANNEL = 16384i32,
    BIDIRECTIONAL_CHANNEL = 24576i32,
}
impl TryFrom<i32> for PnChannelDirectionEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::MANUFACTURER_SPECIFIC,
            8192i32 => Self::INPUT_CHANNEL,
            16384i32 => Self::OUTPUT_CHANNEL,
            24576i32 => Self::BIDIRECTIONAL_CHANNEL,
            r => {
                log::error!(
                    "Got unexpected value for enum PnChannelDirectionEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnChannelDirectionEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnChannelDirectionEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnChannelDirectionEnumeration> for i32 {
    fn from(value: PnChannelDirectionEnumeration) -> Self {
        value as i32
    }
}
impl From<PnChannelDirectionEnumeration> for opcua::types::Variant {
    fn from(value: PnChannelDirectionEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnChannelDirectionEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnChannelDirectionEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnChannelDirectionEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnChannelDirectionEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnChannelDirectionEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnChannelMaintenanceEnumeration {
    FAULT = 0i32,
    MAINTENANCE_REQUIRED = 512i32,
    MAINTENANCE_DEMANDED = 1024i32,
    USE_QUALIFIED_CHANNEL_QUALIFIER = 1536i32,
}
impl TryFrom<i32> for PnChannelMaintenanceEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::FAULT,
            512i32 => Self::MAINTENANCE_REQUIRED,
            1024i32 => Self::MAINTENANCE_DEMANDED,
            1536i32 => Self::USE_QUALIFIED_CHANNEL_QUALIFIER,
            r => {
                log::error!(
                    "Got unexpected value for enum PnChannelMaintenanceEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnChannelMaintenanceEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnChannelMaintenanceEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnChannelMaintenanceEnumeration> for i32 {
    fn from(value: PnChannelMaintenanceEnumeration) -> Self {
        value as i32
    }
}
impl From<PnChannelMaintenanceEnumeration> for opcua::types::Variant {
    fn from(value: PnChannelMaintenanceEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnChannelMaintenanceEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnChannelMaintenanceEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnChannelMaintenanceEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnChannelMaintenanceEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnChannelMaintenanceEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnChannelSpecifierEnumeration {
    ALL_DISAPPEARS = 0i32,
    APPEARS = 2048i32,
    DISAPPEARS = 4096i32,
    DISAPPEARS_OTHER_REMAIN = 6144i32,
}
impl TryFrom<i32> for PnChannelSpecifierEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::ALL_DISAPPEARS,
            2048i32 => Self::APPEARS,
            4096i32 => Self::DISAPPEARS,
            6144i32 => Self::DISAPPEARS_OTHER_REMAIN,
            r => {
                log::error!(
                    "Got unexpected value for enum PnChannelSpecifierEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnChannelSpecifierEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnChannelSpecifierEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnChannelSpecifierEnumeration> for i32 {
    fn from(value: PnChannelSpecifierEnumeration) -> Self {
        value as i32
    }
}
impl From<PnChannelSpecifierEnumeration> for opcua::types::Variant {
    fn from(value: PnChannelSpecifierEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnChannelSpecifierEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnChannelSpecifierEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnChannelSpecifierEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnChannelSpecifierEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnChannelSpecifierEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnChannelTypeEnumeration {
    UNSPECIFIC = 0i32,
    __1BIT = 1i32,
    __2BIT = 2i32,
    __4BIT = 3i32,
    __8BIT = 4i32,
    __16BIT = 5i32,
    __32BIT = 6i32,
    __64BIT = 7i32,
}
impl TryFrom<i32> for PnChannelTypeEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::UNSPECIFIC,
            1i32 => Self::__1BIT,
            2i32 => Self::__2BIT,
            3i32 => Self::__4BIT,
            4i32 => Self::__8BIT,
            5i32 => Self::__16BIT,
            6i32 => Self::__32BIT,
            7i32 => Self::__64BIT,
            r => {
                log::error!(
                    "Got unexpected value for enum PnChannelTypeEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnChannelTypeEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnChannelTypeEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnChannelTypeEnumeration> for i32 {
    fn from(value: PnChannelTypeEnumeration) -> Self {
        value as i32
    }
}
impl From<PnChannelTypeEnumeration> for opcua::types::Variant {
    fn from(value: PnChannelTypeEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnChannelTypeEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnChannelTypeEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnChannelTypeEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnChannelTypeEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnChannelTypeEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnDeviceStateEnumeration {
    OFFLINE = 0i32,
    OFFLINE_DOCKING = 1i32,
    ONLINE = 2i32,
    ONLINE_DOCKING = 3i32,
}
impl TryFrom<i32> for PnDeviceStateEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::OFFLINE,
            1i32 => Self::OFFLINE_DOCKING,
            2i32 => Self::ONLINE,
            3i32 => Self::ONLINE_DOCKING,
            r => {
                log::error!(
                    "Got unexpected value for enum PnDeviceStateEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnDeviceStateEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnDeviceStateEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnDeviceStateEnumeration> for i32 {
    fn from(value: PnDeviceStateEnumeration) -> Self {
        value as i32
    }
}
impl From<PnDeviceStateEnumeration> for opcua::types::Variant {
    fn from(value: PnDeviceStateEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnDeviceStateEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnDeviceStateEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnDeviceStateEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnDeviceStateEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnDeviceStateEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnLinkStateEnumeration {
    UP = 1i32,
    DOWN = 2i32,
    TESTING = 3i32,
    UNKNOWN = 4i32,
    DORMANT = 5i32,
    NOT_PRESENT = 6i32,
    LOWER_LAYER_DOWN = 7i32,
}
impl TryFrom<i32> for PnLinkStateEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            1i32 => Self::UP,
            2i32 => Self::DOWN,
            3i32 => Self::TESTING,
            4i32 => Self::UNKNOWN,
            5i32 => Self::DORMANT,
            6i32 => Self::NOT_PRESENT,
            7i32 => Self::LOWER_LAYER_DOWN,
            r => {
                log::error!(
                    "Got unexpected value for enum PnLinkStateEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnLinkStateEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnLinkStateEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnLinkStateEnumeration> for i32 {
    fn from(value: PnLinkStateEnumeration) -> Self {
        value as i32
    }
}
impl From<PnLinkStateEnumeration> for opcua::types::Variant {
    fn from(value: PnLinkStateEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnLinkStateEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnLinkStateEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnLinkStateEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnLinkStateEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnLinkStateEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnModuleStateEnumeration {
    NO_MODULE = 0i32,
    WRONG_MODULE = 1i32,
    PROPER_MODULE = 2i32,
    SUBSTITUTE = 3i32,
    OK = 4i32,
}
impl TryFrom<i32> for PnModuleStateEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::NO_MODULE,
            1i32 => Self::WRONG_MODULE,
            2i32 => Self::PROPER_MODULE,
            3i32 => Self::SUBSTITUTE,
            4i32 => Self::OK,
            r => {
                log::error!(
                    "Got unexpected value for enum PnModuleStateEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnModuleStateEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnModuleStateEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnModuleStateEnumeration> for i32 {
    fn from(value: PnModuleStateEnumeration) -> Self {
        value as i32
    }
}
impl From<PnModuleStateEnumeration> for opcua::types::Variant {
    fn from(value: PnModuleStateEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnModuleStateEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnModuleStateEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnModuleStateEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnModuleStateEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnModuleStateEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnPortStateEnumeration {
    UNKNOWN = 0i32,
    DISABLED_DISCARDING = 1i32,
    BLOCKING = 2i32,
    LISTENING = 3i32,
    LEARNING = 4i32,
    FORWARDING = 5i32,
    BROKEN = 6i32,
}
impl TryFrom<i32> for PnPortStateEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::UNKNOWN,
            1i32 => Self::DISABLED_DISCARDING,
            2i32 => Self::BLOCKING,
            3i32 => Self::LISTENING,
            4i32 => Self::LEARNING,
            5i32 => Self::FORWARDING,
            6i32 => Self::BROKEN,
            r => {
                log::error!(
                    "Got unexpected value for enum PnPortStateEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnPortStateEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnPortStateEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnPortStateEnumeration> for i32 {
    fn from(value: PnPortStateEnumeration) -> Self {
        value as i32
    }
}
impl From<PnPortStateEnumeration> for opcua::types::Variant {
    fn from(value: PnPortStateEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnPortStateEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnPortStateEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnPortStateEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnPortStateEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnPortStateEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnSubmoduleAddInfoEnumeration {
    NO_ADD_INFO = 0i32,
    TAKEOVER_NOT_ALLOWED = 1i32,
}
impl TryFrom<i32> for PnSubmoduleAddInfoEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::NO_ADD_INFO,
            1i32 => Self::TAKEOVER_NOT_ALLOWED,
            r => {
                log::error!(
                    "Got unexpected value for enum PnSubmoduleAddInfoEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnSubmoduleAddInfoEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnSubmoduleAddInfoEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnSubmoduleAddInfoEnumeration> for i32 {
    fn from(value: PnSubmoduleAddInfoEnumeration) -> Self {
        value as i32
    }
}
impl From<PnSubmoduleAddInfoEnumeration> for opcua::types::Variant {
    fn from(value: PnSubmoduleAddInfoEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnSubmoduleAddInfoEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnSubmoduleAddInfoEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnSubmoduleAddInfoEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnSubmoduleAddInfoEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnSubmoduleAddInfoEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnSubmoduleARInfoEnumeration {
    OWN = 0i32,
    APPLICATION_READY_PENDING = 128i32,
    SUPERORDINATED_LOCKED = 256i32,
    LOCKED_BY_IO_CONTROLLER = 384i32,
    LOCKED_BY_IO_SUPERVISOR = 512i32,
}
impl TryFrom<i32> for PnSubmoduleARInfoEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::OWN,
            128i32 => Self::APPLICATION_READY_PENDING,
            256i32 => Self::SUPERORDINATED_LOCKED,
            384i32 => Self::LOCKED_BY_IO_CONTROLLER,
            512i32 => Self::LOCKED_BY_IO_SUPERVISOR,
            r => {
                log::error!(
                    "Got unexpected value for enum PnSubmoduleARInfoEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnSubmoduleARInfoEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnSubmoduleARInfoEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnSubmoduleARInfoEnumeration> for i32 {
    fn from(value: PnSubmoduleARInfoEnumeration) -> Self {
        value as i32
    }
}
impl From<PnSubmoduleARInfoEnumeration> for opcua::types::Variant {
    fn from(value: PnSubmoduleARInfoEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnSubmoduleARInfoEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnSubmoduleARInfoEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnSubmoduleARInfoEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnSubmoduleARInfoEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnSubmoduleARInfoEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(i32)]
pub enum PnSubmoduleIdentInfoEnumeration {
    OK = 0i32,
    SUBSTITUTE = 2048i32,
    WRONG = 4096i32,
    NO_SUBMODULE = 6144i32,
}
impl TryFrom<i32> for PnSubmoduleIdentInfoEnumeration {
    type Error = opcua::types::StatusCode;
    fn try_from(value: i32) -> Result<Self, <Self as TryFrom<i32>>::Error> {
        Ok(match value {
            0i32 => Self::OK,
            2048i32 => Self::SUBSTITUTE,
            4096i32 => Self::WRONG,
            6144i32 => Self::NO_SUBMODULE,
            r => {
                log::error!(
                    "Got unexpected value for enum PnSubmoduleIdentInfoEnumeration: {}",
                    r
                );
                return Err(opcua::types::StatusCode::BadUnexpectedError);
            }
        })
    }
}
#[cfg(feature = "xml")]
impl opcua::types::xml::FromXml for PnSubmoduleIdentInfoEnumeration {
    fn from_xml(
        element: &opcua::types::xml::XmlElement,
        ctx: &opcua::types::xml::XmlContext<'_>,
    ) -> Result<Self, opcua::types::xml::FromXmlError> {
        let val = i32::from_xml(element, ctx)?;
        Ok(Self::try_from(val).map_err(|e| {
            format!(
                "Got unexpected value for enum PnSubmoduleIdentInfoEnumeration: {}",
                e
            )
        })?)
    }
}
impl From<PnSubmoduleIdentInfoEnumeration> for i32 {
    fn from(value: PnSubmoduleIdentInfoEnumeration) -> Self {
        value as i32
    }
}
impl From<PnSubmoduleIdentInfoEnumeration> for opcua::types::Variant {
    fn from(value: PnSubmoduleIdentInfoEnumeration) -> Self {
        Self::from(value as i32)
    }
}
impl opcua::types::AsVariantRef for PnSubmoduleIdentInfoEnumeration {
    fn as_variant(&self, _ctx: &opcua::types::EncodingContext) -> opcua::types::Variant {
        (*self as i32).into()
    }
}
#[cfg(feature = "json")]
impl<'de> serde::de::Deserialize<'de> for PnSubmoduleIdentInfoEnumeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        struct EnumVisitor;
        use serde::de::Error;
        impl<'de> serde::de::Visitor<'de> for EnumVisitor {
            type Value = i32;
            fn expecting(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(formatter, "i32")
            }
        }
        let value = deserializer.deserialize_i32(EnumVisitor)?;
        Self::try_from(value)
            .map_err(|e| D::Error::custom(format!("Failed to deserialize i32: {:?}", e)))
    }
}
#[cfg(feature = "json")]
impl serde::ser::Serialize for PnSubmoduleIdentInfoEnumeration {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<<S as serde::ser::Serializer>::Ok, <S as serde::ser::Serializer>::Error>
    where
        S: serde::ser::Serializer,
    {
        serializer.serialize_i32(*self as i32)
    }
}
impl opcua::types::BinaryEncodable for PnSubmoduleIdentInfoEnumeration {
    fn byte_len(&self) -> usize {
        4usize
    }
    fn encode<S: std::io::Write + ?Sized>(
        &self,
        stream: &mut S,
    ) -> opcua::types::EncodingResult<usize> {
        opcua::types::write_i32(stream, *self as i32)
    }
}
impl opcua::types::BinaryDecodable for PnSubmoduleIdentInfoEnumeration {
    fn decode<S: std::io::Read>(
        stream: &mut S,
        _: &opcua::types::DecodingOptions,
    ) -> opcua::types::EncodingResult<Self> {
        let value = opcua::types::read_i32(stream)?;
        Ok(Self::try_from(value)?)
    }
}
