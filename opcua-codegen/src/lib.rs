mod error;
mod ids;
pub mod nodeset;
mod types;
mod utils;

use std::{
    collections::{HashMap, HashSet},
    io::Write,
    path::Path,
};

pub use error::CodeGenError;
use ids::{generate_node_ids, NodeIdCodeGenTarget};
use nodeset::{generate_events, generate_target, make_root_module, NodeSetCodeGenTarget};
use opcua_xml::load_nodeset2_file;
use serde::{Deserialize, Serialize};
use syn::File;
pub use types::{
    base_ignored_types, base_native_type_mappings, basic_types_import_map, BsdTypeLoader,
    CodeGenItemConfig, GeneratedItem, ItemDefinition, LoadedType, LoadedTypes, StructureField,
    StructureFieldType, StructuredType,
};
use types::{generate_types, generate_xml_loader_impl, ExternalType};
pub use utils::{create_module_file, GeneratedOutput};

pub fn write_to_directory<T: GeneratedOutput>(
    dir: &str,
    root_path: &str,
    header: &str,
    mut items: Vec<T>,
) -> Result<Vec<String>, CodeGenError> {
    let mut modules = Vec::new();
    let mut modules_seen = HashSet::new();
    let dir = format!("{}/{}", root_path, dir);
    let _ = std::fs::remove_dir_all(&dir);
    std::fs::create_dir_all(&dir)
        .map_err(|e| CodeGenError::io(&format!("Failed to create dir {}", dir), e))?;

    items.sort_by_key(|a| a.name().to_lowercase());

    for gen in items {
        let module = gen.module().to_owned();
        let path = Path::new(&format!("{}/{}.rs", dir, module)).to_owned();
        let is_new = !path.exists();
        let mut file = std::fs::File::options()
            .append(true)
            .create(true)
            .open(format!("{}/{}.rs", dir, module))
            .map_err(|e| {
                CodeGenError::io(&format!("Failed to open file {}/{}.rs", dir, module), e)
            })?;
        if is_new {
            file.write_all(header.as_bytes()).map_err(|e| {
                CodeGenError::io(&format!("Failed to write to file {}/{}.rs", dir, module), e)
            })?;
        }
        // Do it this way so that we keep a stable ordering.
        if modules_seen.insert(module.clone()) {
            modules.push(module.clone());
        }
        file.write_all(prettyplease::unparse(&gen.to_file()).as_bytes())
            .map_err(|e| {
                CodeGenError::io(&format!("Failed to write to file {}/{}.rs", dir, module), e)
            })?;
    }

    Ok(modules)
}

pub fn write_module_file(
    dir: &str,
    root_path: &str,
    header: &str,
    file: File,
) -> Result<(), CodeGenError> {
    let mut mod_file = std::fs::File::options()
        .append(true)
        .create(true)
        .open(format!("{}/{}/{}", root_path, dir, "mod.rs"))
        .map_err(|e| CodeGenError::io(&format!("Failed to open file {}/mod.rs", dir), e))?;
    mod_file
        .write_all(header.as_bytes())
        .map_err(|e| CodeGenError::io(&format!("Failed to write to file {}/mod.rs", dir), e))?;
    mod_file
        .write_all(prettyplease::unparse(&file).as_bytes())
        .map_err(|e| CodeGenError::io(&format!("Failed to write to file {}/mod.rs", dir), e))?;

    Ok(())
}

fn make_header(path: &str, extra: &[&str]) -> String {
    let mut header = format!(
        r#"// This file was autogenerated from {} by opcua-codegen
//
// DO NOT EDIT THIS FILE
"#,
        path
    );

    for extra in extra {
        if !extra.is_empty() {
            header.push('\n');
            header.push_str(extra.trim());
        }
    }
    if !header.ends_with('\n') {
        header.push('\n');
    }

    header
}

pub fn run_codegen(config: &CodeGenConfig, root_path: &str) -> Result<(), CodeGenError> {
    for target in &config.targets {
        match target {
            CodeGenTarget::Types(t) => {
                println!("Running data type code generation for {}", t.file_path);
                let (types, target_namespace) = generate_types(t, root_path)?;
                println!("Writing {} types to {}", types.len(), t.output_dir);

                let header = make_header(&t.file_path, &[&config.extra_header, &t.extra_header]);

                let object_ids = types
                    .iter()
                    .filter_map(|v| {
                        v.object_id
                            .as_ref()
                            .map(|i| (i.to_string(), v.name.clone()))
                    })
                    .collect();
                let modules = write_to_directory(&t.output_dir, root_path, &header, types)?;
                let mut module_file = create_module_file(modules);
                module_file
                    .items
                    .extend(generate_xml_loader_impl(object_ids, &target_namespace).into_iter());

                write_module_file(&t.output_dir, root_path, &header, module_file)?;
            }
            CodeGenTarget::Nodes(n) => {
                println!("Running node set code generation for {}", n.file_path);
                println!("Loading node set from {}", n.file_path);
                let node_set = std::fs::read_to_string(format!("{}/{}", root_path, &n.file_path))
                    .map_err(|e| {
                    CodeGenError::io(&format!("Failed to read file {}", n.file_path), e)
                })?;
                let node_set = load_nodeset2_file(&node_set)?;
                let nodes = node_set.node_set.as_ref().ok_or_else(|| {
                    CodeGenError::Other("Missing UANodeSet in xml schema".to_owned())
                })?;
                println!("Found {} nodes in node set", nodes.nodes.len());

                let chunks = generate_target(n, nodes, &config.preferred_locale, root_path)?;
                let module_file = make_root_module(&chunks, n)?;

                println!("Writing {} files to {}", chunks.len() + 1, n.output_dir);

                let header = make_header(&n.file_path, &[&config.extra_header, &n.extra_header]);

                write_to_directory(&n.output_dir, root_path, &header, chunks)?;
                write_module_file(&n.output_dir, root_path, &header, module_file)?;

                if let Some(events_target) = &n.events {
                    println!("Generating events to {}", events_target.output_dir);
                    let events = generate_events(nodes)?;
                    let cnt = events.len();
                    let header = make_header(
                        &n.file_path,
                        &[&config.extra_header, &events_target.extra_header],
                    );
                    let modules =
                        write_to_directory(&events_target.output_dir, root_path, &header, events)?;
                    write_module_file(
                        &events_target.output_dir,
                        root_path,
                        &header,
                        create_module_file(modules),
                    )?;
                    println!("Created {} event types", cnt);
                }
            }
            CodeGenTarget::Ids(n) => {
                println!("Running node ID code generation for {}", n.file_path);
                let gen = generate_node_ids(n, root_path)?;
                let mut file = std::fs::File::options()
                    .create(true)
                    .truncate(true)
                    .write(true)
                    .open(format!("{}/{}", root_path, &n.output_file))
                    .map_err(|e| {
                        CodeGenError::io(&format!("Failed to open file {}", n.output_file), e)
                    })?;
                let header = make_header(&n.file_path, &[&config.extra_header, &n.extra_header]);
                file.write_all(header.as_bytes()).map_err(|e| {
                    CodeGenError::io(&format!("Failed to write to file {}", n.output_file), e)
                })?;
                file.write_all(prettyplease::unparse(&gen).as_bytes())
                    .map_err(|e| {
                        CodeGenError::io(&format!("Failed to write to file {}", n.output_file), e)
                    })?;
            }
        }
    }

    Ok(())
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TypeCodeGenTarget {
    pub file_path: String,
    pub output_dir: String,
    #[serde(default)]
    pub ignore: Vec<String>,
    #[serde(default)]
    pub types_import_map: HashMap<String, ExternalType>,
    #[serde(default)]
    pub default_excluded: HashSet<String>,
    #[serde(default)]
    pub enums_single_file: bool,
    #[serde(default)]
    pub structs_single_file: bool,
    #[serde(default)]
    pub extra_header: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type")]
#[serde(rename_all = "snake_case")]
pub enum CodeGenTarget {
    Types(TypeCodeGenTarget),
    Nodes(NodeSetCodeGenTarget),
    Ids(NodeIdCodeGenTarget),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct CodeGenConfig {
    #[serde(default)]
    pub extra_header: String,
    #[serde(default)]
    pub preferred_locale: String,
    pub targets: Vec<CodeGenTarget>,
}

impl CodeGenConfig {
    pub fn update_paths(&mut self, root_path: &str) {
        for target in &mut self.targets {
            match target {
                CodeGenTarget::Types(t) => {
                    t.file_path = format!("{}/{}", root_path, t.file_path);
                    t.output_dir = format!("{}/{}", root_path, t.output_dir);
                }
                CodeGenTarget::Nodes(t) => {
                    t.file_path = format!("{}/{}", root_path, t.file_path);
                    t.output_dir = format!("{}/{}", root_path, t.output_dir);
                    for ty in &mut t.types {
                        ty.file_path = format!("{}/{}", root_path, ty.file_path);
                    }
                }
                CodeGenTarget::Ids(t) => {
                    t.file_path = format!("{}/{}", root_path, t.file_path);
                    t.output_file = format!("{}/{}", root_path, t.output_file);
                }
            }
        }
    }
}

const BASE_NAMESPACE: &str = "http://opcfoundation.org/UA/";
