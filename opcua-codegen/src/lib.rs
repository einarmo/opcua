mod error;
pub mod nodeset;
mod types;
mod utils;

use std::{
    collections::{HashMap, HashSet},
    io::Write,
    path::Path,
};

pub use error::CodeGenError;
use nodeset::{generate_target, make_root_module, NodeSetCodeGenTarget};
use serde::{Deserialize, Serialize};
use syn::File;
pub use types::{
    base_ignored_types, base_json_serialized_types, base_native_type_mappings,
    basic_types_import_map, BsdTypeLoader, CodeGenItemConfig, GeneratedItem, ItemDefinition,
    LoadedType, LoadedTypes, StructureField, StructureFieldType, StructuredType,
};
use types::{generate_types, ExternalType};
pub use utils::{create_module_file, GeneratedOutput};

pub fn write_to_directory<T: GeneratedOutput>(
    dir: &str,
    header: &str,
    mut items: Vec<T>,
) -> Result<Vec<String>, CodeGenError> {
    let mut modules = Vec::new();
    let mut modules_seen = HashSet::new();
    let _ = std::fs::remove_dir_all(dir);
    std::fs::create_dir_all(dir)
        .map_err(|e| CodeGenError::io(&format!("Failed to create dir {}", dir), e))?;

    items.sort_by(|a, b| a.name().to_lowercase().cmp(&b.name().to_lowercase()));

    for gen in items {
        let module = gen.module().to_owned();
        let path = Path::new(&format!("{}/{}.rs", dir, module)).to_owned();
        let is_new = !path.exists();
        let mut file = std::fs::File::options()
            .append(true)
            .create(true)
            .open(format!("{}/{}.rs", dir, module))
            .map_err(|e| {
                CodeGenError::io(&format!("Failed to open file {}/{}.rs", dir, module), e)
            })?;
        if is_new {
            file.write_all(header.as_bytes()).map_err(|e| {
                CodeGenError::io(&format!("Failed to write to file {}/{}.rs", dir, module), e)
            })?;
        }
        // Do it this way so that we keep a stable ordering.
        if modules_seen.insert(module.clone()) {
            modules.push(module.clone());
        }
        file.write_all(&prettyplease::unparse(&gen.to_file()).as_bytes())
            .map_err(|e| {
                CodeGenError::io(&format!("Failed to write to file {}/{}.rs", dir, module), e)
            })?;
    }

    Ok(modules)
}

pub fn write_module_file(dir: &str, header: &str, file: File) -> Result<(), CodeGenError> {
    let mut mod_file = std::fs::File::options()
        .append(true)
        .create(true)
        .open(format!("{}/{}", dir, "mod.rs"))
        .map_err(|e| CodeGenError::io(&format!("Failed to open file {}/mod.rs", dir), e))?;
    mod_file
        .write_all(header.as_bytes())
        .map_err(|e| CodeGenError::io(&format!("Failed to write to file {}/mod.rs", dir), e))?;
    mod_file
        .write_all(&prettyplease::unparse(&file).as_bytes())
        .map_err(|e| CodeGenError::io(&format!("Failed to write to file {}/mod.rs", dir), e))?;

    Ok(())
}

fn make_header(path: &str, extra: &str) -> String {
    let mut header = format!(
        r#"// This file was autogenerated from {} by opcua-codegen
//
// DO NOT EDIT THIS FILE
"#,
        path
    );

    if !extra.is_empty() {
        header = format!(
            r#"{}
//
{header}"#,
            extra.trim()
        );
    }

    header
}

pub fn run_codegen(config: &CodeGenConfig) -> Result<(), CodeGenError> {
    for target in &config.targets {
        match target {
            CodeGenTarget::Types(t) => {
                println!("Running data type code generation for {}", t.file_path);
                let types = generate_types(config, t)?;
                println!("Writing {} types to {}", types.len(), t.output_dir);

                let header = make_header(&t.file_path, &config.extra_header);

                let modules = write_to_directory(&t.output_dir, &header, types)?;
                let module_file = create_module_file(modules);
                write_module_file(&t.output_dir, &header, module_file)?;
            }
            CodeGenTarget::Nodes(n) => {
                println!("Running node set code generation for {}", n.file_path);
                let chunks =
                    generate_target(&n, &config.opcua_crate_path, &config.preferred_locale)?;
                let module_file = make_root_module(&chunks, &config.opcua_crate_path, &n)?;

                println!("Writing {} files to {}", chunks.len() + 1, n.output_dir);

                let header = make_header(&n.file_path, &config.extra_header);

                write_to_directory(&n.output_dir, &header, chunks)?;
                write_module_file(&n.output_dir, &header, module_file)?;
            }
        }
    }

    Ok(())
}

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TypeCodeGenTarget {
    pub file_path: String,
    pub output_dir: String,
    #[serde(default)]
    pub ignore: Vec<String>,
    #[serde(default)]
    pub json_serialized_types: Vec<String>,
    #[serde(default)]
    pub types_import_map: HashMap<String, ExternalType>,
    #[serde(default)]
    pub default_excluded: HashSet<String>,
    #[serde(default)]
    pub enums_single_file: bool,
    #[serde(default)]
    pub structs_single_file: bool,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type")]
#[serde(rename_all = "snake_case")]
pub enum CodeGenTarget {
    Types(TypeCodeGenTarget),
    Nodes(NodeSetCodeGenTarget),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct CodeGenConfig {
    #[serde(default)]
    pub extra_header: String,
    #[serde(default = "defaults::opcua_crate_path")]
    pub opcua_crate_path: String,
    #[serde(default)]
    pub preferred_locale: String,
    pub targets: Vec<CodeGenTarget>,
}

mod defaults {
    pub fn opcua_crate_path() -> String {
        "opcua".to_owned()
    }
}
